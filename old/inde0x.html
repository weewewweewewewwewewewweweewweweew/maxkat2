
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>КиноМакКат</title>

    <!-- PWA Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1e293b"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="КиноМакКат">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    
    <style>
:root {--bg-color:#0f172a;--card-color:#1e293b;--text-color:#e2e8f0;--text-muted:#94a3b8;--primary-color:#3b82f6;--pink-color:#ec4899;--star-color:#facc15;--danger-color:#ef4444;--border-radius:12px;--select-arrow-color:'%2394a3b8';}
body.light-theme { --bg-color: #f3f0e9; --card-color: #f9f7f2; --text-color: #5c5240; --text-muted: #8d8370; --primary-color: #c5874c; --select-arrow-color: '%238d8370'; --danger-color: #e57373; }
body.light-theme .movie-card { box-shadow: 0 4px 6px -1px rgba(92,82,64,0.07), 0 2px 4px -2px rgba(92,82,64,0.07); border: 1px solid #e5e2da; }
body.light-theme #search-input, body.light-theme .list-search-input, body.light-theme .filter-group select, body.light-theme .form-group select, body.light-theme .form-group textarea, body.light-theme .form-group input[type="number"], body.light-theme .comment-input, body.light-theme .score-slider, body.light-theme .password-box input, body.light-theme .import-form input[type="file"], body.light-theme #episode-ai-search-input { background-color: #e3dcd1; color: var(--text-color); border-color: #d1cdc4; }
body.light-theme .rating-block__comment, body.light-theme .plan-block__comment { background-color: var(--bg-color); }
body.light-theme .tab-button:not(.active) { background-color: #edeae4; border: 1px solid #d1cdc4; color: var(--text-muted); }
body.light-theme .tab-button:not(.active):hover { background-color: #d7d0c4; }
body.light-theme #random-movie-btn, body.light-theme #random-plan-btn, body.light-theme #episode-ai-search-btn { background-color: #e3dcd1; border-color: #d7d0c4; }
body.light-theme .rated-movie-item:hover, body.light-theme .planned-movie-item:hover { background-color: #fdfcf9; }
body.light-theme .modal-content, body.light-theme .password-box { background-color: var(--card-color); box-shadow: 0 10px 15px -3px rgba(92,82,64,0.1), 0 4px 6px -4px rgba(92,82,64,0.1); border: 1px solid #dcd7ce; }
body.light-theme .progress-info, body.light-theme .progress-bar-container { background-color: #e3dcd1; }
body.light-theme .movie-card__our-rating { background-color: rgba(249, 247, 242, 0.8); color: var(--text-color); backdrop-filter: blur(2px); }
body.light-theme .user-stats-card, body.light-theme .last-actions-list li { background-color: var(--card-color); border: 1px solid #e5e2da; }
body.light-theme .bar-container { background-color: #e3dcd1; }
body.light-theme .bar-fill { color: #fdfaf3; }
body.light-theme #episodes-list-container { background-color: var(--bg-color); border-radius: var(--border-radius); padding: 0.75rem; }
body.light-theme #episodes-list { background-color: transparent; padding: 0; }
body.light-theme .episode-item { background-color: var(--card-color); border: 1px solid #e5e2da; }
body.light-theme .country-filter-toggle:hover { background-color: #e3dcd1; }
body.light-theme .cast-list .actor-item:hover { background-color: #f0ede8; }
body.light-theme .episode-item.highlighted { background-color: #fde8d3; border-color: var(--primary-color); }
body.light-theme .ai-toast-notification { background: rgba(243, 240, 233, 0.9); color: var(--text-color); }

body.light-theme #ratings-filters,
body.light-theme #plans-filters,
body.light-theme #filmography-filters {
    background-color: transparent;
    border: 1px solid #e5e2da;
}
body.light-theme .rated-movie-item,
body.light-theme .planned-movie-item,
body.light-theme .admin-section {
    border: 1px solid #e5e2da;
}

        html, body {scroll-behavior:smooth;}
        body.modal-open { overflow: hidden; }
        *{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent;}
        button, a, div, select, textarea, input {outline: none !important;}
        body{background-color:var(--bg-color);color:var(--text-color);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;margin:0;padding:0 1rem 5rem; overflow-x: hidden; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; transition: background-color .3s, color .3s;}
        input, textarea { -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; }
        input::-webkit-search-decoration, input::-webkit-search-cancel-button, input::-webkit-search-results-button, input::-webkit-search-results-decoration { display: none; }
        input[type="password"]::-ms-reveal, input[type="password"]::-ms-clear { display: none !important; }
        .password-prompt{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(15,23,42,.95);z-index:9999;display:none;align-items:center;justify-content:center;flex-direction:column;gap:1rem;}.password-prompt.visible{display:flex;}.password-box{position:relative;background-color:var(--card-color);padding:2rem;border-radius:var(--border-radius);text-align:center;box-shadow:0 10px 25px rgba(0,0,0,.3);max-width: 400px; width: 90%;}.password-box h2{margin-bottom:1rem;color:var(--text-color);}.password-box input{width:100%;padding:.75rem 2.5rem .75rem 1rem;font-size:16px;background-color:#334155;border:1px solid #475569;color:var(--text-color);border-radius:var(--border-radius);margin-bottom:1rem;}.password-box button{width:100%;padding:.75rem;font-size:1.1rem;font-weight:700;background-color:var(--primary-color);color:#fff;border:none;border-radius:var(--border-radius);cursor:pointer;}
        header{text-align:center;padding:1.5rem 0;}header h1{font-size:2rem;display:flex;align-items:center;justify-content:center;gap:0.5rem;}
        #popcorn-btn { cursor: pointer; transition: transform .2s; }
        #popcorn-btn:hover { transform: scale(1.2); }
        header p{color:var(--text-muted);margin-top:0.5rem;min-height: 20px;}
        nav{display:flex;gap:0.5rem;margin-bottom:1.5rem;justify-content:center;}.tab-button{flex-grow:1;padding:0.75rem 1rem;border:1px solid var(--card-color);background-color:var(--card-color);color:var(--text-color);font-size:1.1rem;font-weight:500;border-radius:var(--border-radius);cursor:pointer;transition:background-color .2s,color .2s, border-color .2s;}.tab-button.active{background-color:var(--primary-color);color:#fff;border-color:var(--primary-color);}.tab-button:not(.active):hover{background-color:#334155;}
        #admin-tab-btn { flex-grow: 0; padding: 0.75rem;}
        .view{display:none;}.view.active{display:block;}
        #search-form{display:flex;gap:.75rem;margin-bottom:1.5rem; align-items: stretch; flex-wrap: wrap; position: relative;}
        #random-movie-btn, #random-plan-btn, #episode-ai-search-btn { padding: 0.75rem; font-size: 1.2rem; background-color: var(--card-color); color: var(--text-color); border: 1px solid #334155; border-radius: var(--border-radius); cursor: pointer; transition: all .2s; flex-shrink: 0; }
        #random-movie-btn:hover, #random-plan-btn:hover, #episode-ai-search-btn:hover { background-color: #334155; transform: scale(1.05); }
        /* [НОВОЕ] Стили для верхнего ряда поиска */
        .search-top-row { display: flex; gap: 0.75rem; flex-basis: 100%; align-items: flex-end; }
        .search-top-row .filter-group { flex-grow: 1; }
        .search-controls-wrapper { display: flex; gap: 0.75rem; flex-grow: 1; flex-basis: 100%; }
        .search-input-container { position: relative; flex-grow: 1; }
        #search-input, #new-kp-key-input, .list-search-input, #episode-ai-search-input {width:100%;padding:0.75rem 2.5rem .75rem 1rem;font-size:16px;background-color:#334155;border:1px solid #475569;color:var(--text-color);border-radius:var(--border-radius); height: 100%;}
        #episode-ai-search-input { font-size: 1rem; height: auto; }
        #admin-password-input { font-size: 16px !important; padding: .75rem 1rem; }
        .input-clear-btn { position: absolute; top: 50%; right: 0.5rem; transform: translateY(-50%); background: none; border: none; color: var(--text-muted); font-size: 1.5rem; cursor: pointer; display: none; padding: 0.25rem; line-height: 1; }
        #search-button, #ai-search-button, .list-search-btn, #episode-ai-search-btn {padding:0.75rem;font-size:1.2rem;background-color:var(--primary-color);color:#fff;border:none;border-radius:var(--border-radius);cursor:pointer;transition:background-color .2s; min-width: 50px;}
        #search-button {flex-grow: 1;}
        #ai-search-button, #episode-ai-search-btn { background-color: #8b5cf6; padding-left: 1rem; padding-right: 1rem; flex-grow: 0; }
        .list-search-btn {flex-grow: 0;}
        #ai-search-button:hover:not(:disabled), #episode-ai-search-btn:hover:not(:disabled) { background-color: #7c3aed; }
        .filter-group.search-page { flex-basis: 100%; display: flex; flex-direction: column; align-items: stretch; }
        /* [ИЗМЕНЕНО] CSS для скрытия элементов в режиме фильмографии */
        body.filmography-mode .filter-group.search-page,
        body.filmography-mode #ai-search-button {
            display: none;
        }
        .filter-group.search-page .select-wrapper {flex-grow: 1;}
        #movie-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:1rem;}
        .movie-card{background-color:var(--card-color);border-radius:var(--border-radius);overflow:hidden;cursor:pointer;display:flex;flex-direction:column;position:relative;transition:transform .2s, background-color .3s, box-shadow .3s;}.movie-card:hover{transform:translateY(-5px);}
        .movie-card__image-container{position:relative;aspect-ratio:2/3;}.movie-card__poster{width:100%;height:100%;object-fit:cover;background-color:#334155;display:block;}
        .movie-card__our-rating{position:absolute;top:8px;left:8px;background-color:rgba(0,0,0,.7);padding:4px 8px;border-radius:8px;font-size:.8rem;font-weight:700;line-height:1.4}.movie-card__our-rating span.score-badge-small {display: block;}
        .rating-entry{display:flex;align-items:center;gap:.25rem}.score-badge-small{display:inline-block;padding:0 5px;border-radius:4px;font-weight:700;color:#fff;margin-left:.25rem}
        .movie-card__special-marker{position:absolute;bottom:8px;right:8px;font-size:1.5rem;text-shadow:0 0 5px black; display: flex; gap: 0.25rem;}
        .movie-card__post-credits-scene{position:absolute;bottom:8px;left:8px;font-size:1.5rem;text-shadow:0 0 5px black;}
        .movie-card__info{padding:.75rem;flex-grow:1;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer; overflow: hidden;}
        .movie-card__title{font-size:1rem;font-weight:600;margin-bottom:0.5rem;display:flex;align-items:flex-start;gap:.5rem; min-height: 2.4em; line-height: 1.2em;}
        .movie-card__title-text{flex:1 1 0;min-width:0; word-break: break-word;}
        .movie-card__details{display:flex;justify-content:space-between;align—items:center;color:var(--text-muted);font-size:.875rem;}
        .movie-card__rating{display:flex;align-items:center;gap:0.25rem;color:var(--star-color);font-weight:700;white-space:nowrap;}
        .movie-card__rating.future-release-icon { font-size: 1.1rem; }
        .movie-card__rating .vote-count { color: var(--text-muted); font-weight: normal; }
        #ratings-filters,#plans-filters{display:grid;grid-template-columns:1fr;gap:.5rem;margin-bottom:1rem;background-color:var(--card-color);padding:1rem;border-radius:var(--border-radius);}
        #filmography-filters { display: none; grid-template-columns:1fr;gap:.5rem;margin-bottom:1rem;background-color:var(--card-color);padding:1rem;border-radius:var(--border-radius);}
        .list-search-container { padding: 0 0 1.5rem 0; }
        .list-search-container .search-controls-wrapper { flex-basis: auto; }
        .filter-row{display:grid;grid-template-columns:1fr 1fr;gap:.5rem;}
        #random-plan-btn-container { display: flex; align-items: flex-end; }
        .filter-group label{display:block;font-size:.8rem;color:var(--text-muted);margin-bottom:0.25rem;}.filter-group select{width:100%;padding:0.5rem;background-color:#334155;color:var(--text-color);border:none;border-radius:8px;}
        #rated-movies-list,#plans-list{display:flex;flex-direction:column;gap:1rem;}
        .rated-movie-item,.planned-movie-item{position:relative;display:flex;gap:1rem;background-color:var(--card-color);border-radius:var(--border-radius);overflow:hidden;padding:1rem;transition:background-color .2s;}
        .rated-movie-item:hover,.planned-movie-item:hover{background-color:#334155;}
        .details-click-area{display:flex;flex-grow:1;cursor:pointer;}
        .list-item__image-container { position: relative; width: 80px; height: 120px; flex-shrink: 0; margin-right: 1rem; border-radius: 8px; overflow: hidden; background-color: #334155;}
        .list-item__poster { width: 100%; height: 100%; object-fit: cover; display: block; }
        .rated-movie__details,.planned-movie__details{flex-grow:1;min-width:0;}
        .rated-movie__details h3,.planned-movie__details h3{font-size:1.1rem;margin-bottom:0.75rem;padding-right:28px;}
        .rating-block,.plan-block{display:flex;align-items:flex-start;gap:.75rem;margin-bottom:1rem;}.rating-block::before,.plan-block::before{content:'';display:block;height:auto;align-self:stretch;width:4px;border-radius:2px;flex-shrink:0;}
        .rating-block--katya::before,.plan-block--katya::before{background-color:var(--pink-color);}.rating-block--maxim::before,.plan-block--maxim::before{background-color:var(--primary-color);}
        .person-rating{flex-grow:1;}.person-rating__header{display:flex;align-items:center;gap:0.5rem;flex-wrap:wrap;}.rating-block__person,.plan-block__person{font-weight:500;}
        .priority-medal,.special-rating-icon{font-size:1.2rem;line-height:1;}.special-rating-icon{margin-left:0.25rem;}
        .rating-block__comment, .plan-block__comment { background-color:#334155; padding:0.5rem .75rem; border-radius:8px; margin-top:0.5rem; font-style:italic; overflow-wrap: break-word; -webkit-hyphens: auto; -ms-hyphens: auto; hyphens: auto; }
        .rating-block__comment a, .plan-block__comment a { color: var(--primary-color); font-weight: bold; text-decoration: underline; }
        .comment-clickable{cursor:pointer;}.comment-clickable:hover{background-color:#475569;}
        .rated-item-footer {font-size:.8rem;color:var(--text-muted);text-align:right;margin-top:1rem;}
        .plan-item-footer {margin-top: 1rem;}
        .plan-footer__bottom-line { display: flex; justify-content: space-between; align-items: center; gap: 1rem; font-size: .8rem; color: var(--text-muted); flex-wrap: wrap;}
        .progress-info{font-weight:bold;background-color:#334155;padding:.25rem .5rem;border-radius:6px;cursor:pointer; transition: all .2s; min-width: 0; flex-grow: 1; flex-shrink: 1; text-overflow: ellipsis; white-space: nowrap; overflow: hidden;}.progress-info:hover{background-color:#4b5563;}
        .progress-info.no-title { flex-grow: 0; }
        .progress-info.expanded-title { white-space: normal; flex-basis: 100%; margin-bottom: 0.5rem; }
        .plan-footer__bottom-line > .date-and-edit { display: flex; align-items: center; gap: 0.5rem; flex-shrink: 0;}
        .edit-progress-btn { cursor: pointer; font-size: 1.1rem; opacity: 0.7; transition: all .2s; }.edit-progress-btn:hover { opacity: 1; transform: scale(1.1); }
        .progress-bar-wrapper{display:flex;align-items:center;gap:.5rem;width:100%; margin-bottom: 0.5rem;}.progress-bar-container{flex-grow:1;height:8px;background-color:#334155;border-radius:4px;overflow:hidden;}.progress-bar-fill{height:100%;width:0;background-color:var(--primary-color);transition:width .3s;}.progress-percentage{font-size:.75rem;font-weight:bold;}
        .delete-btn{position:absolute;top:8px;right:8px;background:rgba(0,0,0,.4);border:none;color:#fff;font-size:1.2rem;cursor:pointer;border-radius:50%;width:28px;height:28px;line-height:28px;text-align:center;transition:all .2s;z-index:5;}.delete-btn:hover{background-color:var(--danger-color);transform:scale(1.1);}
        .add-to-plan-btn{position:absolute;top:8px;right:8px;width:30px;height:30px;background:rgba(0,0,0,0.5);color:white;border:none;border-radius:50%;font-size:1.5rem;font-weight:700;line-height:28px;cursor:pointer;transition:all .2s;z-index:5;}.add-to-plan-btn:hover{background-color:var(--primary-color);transform:scale(1.1);}.add-to-plan-btn.in-plan{background-color:var(--primary-color);cursor:pointer;}
        .loading-indicator, .no-results-message { grid-column: 1 / -1; text-align: center; padding: 1rem; color: var(--text-muted); }
        .google-search-link { display: inline-flex; align-items: center; gap: 0.5rem; margin-top: 1rem; padding: 0.5rem 1rem; background-color: var(--card-color); border: 1px solid #334155; border-radius: 8px; color: var(--text-color); text-decoration: none; transition: background-color .2s; }
        .google-search-link:hover { background-color: #334155; }
        .modal{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.8);z-index:1000;display:none;align-items:center;justify-content:center;padding:1rem;}.modal.visible{display:flex;}.modal-content{background-color:var(--card-color);border-radius:var(--border-radius);padding:0;max-width:500px;width:90%;max-height:95vh;overflow-y:auto;position:relative;}
        #add-to-plan-modal .modal-content, #progress-modal .modal-content, #confirm-modal .modal-content, #message-modal .modal-content, #random-settings-modal .modal-content {padding:1.5rem;}
        #confirm-modal, #message-modal, #random-settings-modal { z-index: 1100; }
        #seasons-modal .modal-content {padding:1.5rem; display:flex; flex-direction:column; gap: 1rem;}
        #confirm-modal .modal-content, #message-modal .modal-content {max-width: 400px;}
        #movie-details-modal .modal-content, #media-modal .modal-content {padding:0;}
        #media-modal .modal-content {max-width: 1200px; width: 95%; max-height: 95vh; background-color: transparent;}
        #media-modal .modal-close { top:0; right: 0; transform: translate(120%, -20%); background: rgba(0,0,0,0.7); }
        .modal-close{position:absolute;top:1rem;right:1rem;background:rgba(0,0,0,.5);border:none;color:#fff;font-size:1.5rem;cursor:pointer;border-radius:50%;width:32px;height:32px;line-height:32px;text-align:center;z-index:10;}#add-to-plan-modal .modal-close, #progress-modal .modal-close, #confirm-modal .modal-close, #seasons-modal .modal-close, #random-settings-modal .modal-close {background:none;color:var(--text-muted);}
        .modal-loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--card-color); display: flex; align-items: center; justify-content: center; z-index: 15; font-size: 1.5rem; color: var(--text-muted); opacity: 1; transition: opacity .3s; }
        .modal-loader.hidden { opacity: 0; pointer-events: none; }
        #modal-body{padding:0;}.modal-poster-large{width:100%;max-height:320px;display:block;object-fit:cover;object-position:50% 20%;background-color:#334155;}
        .modal-info-wrapper{padding:1.5rem;}
        .modal-title-row { display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem; }
        .modal-title-row .title-main-block { flex-grow: 1; }
        .modal-title-row .title-main-block h2 { font-size: 1.8rem; }
        .modal-title-row .title-main-block p { font-size: 1.1rem; color: var(--text-muted); margin-top: 0.25rem; }
        .title-actions { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; flex-shrink: 0; }
        .modal-secondary-actions { display: flex; justify-content: flex-start; align-items: center; gap: 1.5rem; margin-top: 1.25rem; margin-bottom: 1.25rem; padding-left: 2px; flex-wrap: wrap;}
        .collection-link, .frames-link, .google-link, .plan-link, .similar-link, .episodes-link {cursor:pointer;font-size:1.5rem;opacity:0.7;transition: all .2s; text-decoration: none; color: var(--text-color);}
        .collection-link:hover, .frames-link:hover, .google-link:hover, .plan-link:hover, .similar-link:hover, .episodes-link:hover {opacity:1;transform: scale(1.1);}
        #confirm-message, #message-text { margin: 1rem 0 2rem; line-height: 1.5; }
        #confirm-buttons, #message-buttons { display: flex; gap: 1rem; justify-content: flex-end;}
        #confirm-buttons button, #message-buttons button { padding: 0.5rem 1.5rem; }
        .info-grid{display:grid;grid-template-columns:auto 1fr;gap:0.75rem 1rem;align-items:center;}
        .info-grid .label{color:var(--text-muted);font-weight:500;}
        .info-grid .value{font-weight:500; min-width: 0;}
        .info-grid .value.country-flags { font-size: 1.5rem; line-height: 1; }
        .modal-description{margin-top:1.5rem;line-height:1.6;color:var(--text-muted);cursor:pointer;}
        .cast-container { margin-top: 1.5rem; border-top: 1px solid #334155; padding-top: 1.5rem; }
..cast-container { text-align: center; } /* Центрируем заголовок */
.cast-toggle { cursor: pointer; font-weight: 600; font-size: 1.1rem; display: inline-flex; align-items: center; gap: 0.5rem; }
.cast-toggle .arrow { display: inline-block; transition: transform .3s; }
.cast-toggle.expanded .arrow { transform: rotate(180deg); }
.cast-list { max-height: 0; overflow: hidden; transition: max-height .4s ease-in-out, padding .4s ease-in-out; display: flex; gap: 1rem; scrollbar-width: thin; scrollbar-color: var(--primary-color) transparent; }
.cast-list.expanded { 
    max-height: 150px; /* ИЗМЕНЕНО: Немного увеличена высота для многострочных ролей */ 
    overflow-x: auto; 
    overflow-y: hidden; 
    padding-top: 1rem; 
    padding-bottom: 0.5rem; 
    align-items: flex-start; /* ДОБАВЛЕНО: Выравнивание по верху, чтобы карточки не растягивались по высоте */
}

.actor-item { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    text-align: center; 
    width: 80px; 
    flex-shrink: 0; 
    cursor: pointer; 
    padding: 0.25rem; 
    border-radius: 8px; 
    transition: background-color .2s;
    min-height: 120px; /* ДОБАВЛЕНО: Задает минимальную высоту для единообразия */
    justify-content: flex-start; /* ДОБАВЛЕНО: Прижимает контент к верху карточки */
}
.actor-item:hover { background-color: #334155; }
.actor-photo { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #475569; margin-bottom: 0.5rem; }
.actor-info { width: 100%; }
.actor-name { font-weight: 600; font-size: 0.8rem; line-height: 1.2; display: block; }
.actor-character { font-size: 0.75rem; color: var(--text-muted); white-space: normal; line-height: 1.2; margin-top: 0.35rem; font-style: italic; }
        #rating-form,#add-to-plan-form, #random-settings-form {margin-top:1.5rem;border-top:1px solid #334155;padding-top:1.5rem;}
        #progress-form { padding-top:1.5rem;}
        #rating-form{padding:1.5rem;}.add-to-plan-title, .progress-title, #confirm-title, #seasons-title, #message-title, #random-settings-title {font-size:1.3rem;margin-bottom:1rem;text-align:center;padding: 0 2rem;}
        #seasons-title { margin-bottom: 0; }
        .form-group{margin-bottom:1rem;}.form-group label{display:flex; align-items: center; gap: 0.5rem; margin-bottom:0.5rem;font-weight:500;}
        .form-group select,.form-group textarea,.form-group input[type="number"]{width:100%;padding:0.75rem;background-color:#334155;color:var(--text-color);border:1px solid #475569;border-radius:8px;font-size:1rem;-webkit-appearance:none;-moz-appearance:none;appearance:none;}
        .form-group select { padding-right: 2rem; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='var(--select-arrow-color)'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1.5rem; }
        .form-group textarea{height:100px;resize:vertical;}
        .person-switcher{display:flex;justify-content:center;gap:0.5rem;margin-bottom:1.5rem;}.person-btn{display:flex;align-items:center;gap:0.5rem;padding:0.6rem 1.5rem;border:none;border-radius:50px;font-size:1rem;font-weight:700;cursor:pointer;transition:all .2s;background-color:var(--card-color);color:var(--text-muted);}.person-btn.active.katya{background-color:var(--pink-color);color:#fff;}.person-btn.active.maxim{background-color:var(--primary-color);color:#fff;}
        .rating-carousel-container{overflow:hidden;width:100%; display: none;}.rating-carousel-slider{display:flex;width:200%;transition:transform .4s cubic-bezier(.25,.46,.45,.94);}.rating-slide{width:50%;padding:0 5px;}
        #rating-form.person-selected .rating-carousel-container { display: block; }
        .score-display{font-size:3rem;font-weight:bold;text-align:center;margin-bottom:1rem;transition:color .2s;}.score-display.no-rating{font-size:1.5rem;color:var(--text-muted);}.score-slider{-webkit-appearance:none;width:100%;height:15px;background:#334155;border-radius:5px;margin-bottom:1rem;}.score-slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:25px;height:25px;background:var(--primary-color);cursor:pointer;border-radius:50%;}
        .medals-input,.special-rating-input{display:flex;justify-content:center;font-size:2rem;cursor:pointer;margin-bottom:1rem;gap:1.5rem;}.medals-input .medal,.special-rating-input .special-icon{transition:all .2s;opacity:.5;}.medals-input .medal:hover,.special-rating-input .special-icon:hover{opacity:1;}.medals-input .medal.selected,.special-rating-input .special-icon.selected{opacity:1;transform:scale(1.2);}
        .comment-container{position:relative;display:block;}.comment-input{width:100%;height:100px;padding:0.75rem;padding-right:2.5rem;background-color:var(--card-color);border:1px solid #334155;color:var(--text-color);border-radius:8px;font-size:1rem;resize:vertical;margin-top:0.5rem;}.comment-clear-btn{position:absolute;top:18px;right:10px;background:none;border:none;color:var(--text-muted);font-size:1.5rem;cursor:pointer;line-height:1;}
        .form-submit-btn{width:100%;padding:0.75rem;font-size:1rem;font-weight:700;background-color:var(--primary-color);color:#fff;border:none;border-radius:var(--border-radius);cursor:pointer;transition:background-color .2s;margin-top:1.5rem;}
        .form-submit-btn:not(:disabled):hover { background-color: #2563eb; }
        .form-submit-btn.danger{background-color:var(--danger-color);}
        .form-submit-btn:disabled { background-color: #4b5563; cursor: not-allowed; }
        #scroll-to-top{position:fixed;bottom:20px;right:20px;width:40px;height:40px;background-color:var(--primary-color);color:white;border:none;border-radius:50%;font-size:1.5rem;line-height:40px;text-align:center;cursor:pointer;z-index:100;opacity:0;visibility:hidden;transition:opacity .3s,visibility .3s;}
        #scroll-to-top.visible{opacity:1;visibility:visible;}
        .progress-tracker{overflow:hidden;max-height:0;transition:max-height .3s ease-out;}.progress-tracker.visible{max-height:220px;} 
        .progress-inputs{display:flex;gap:.5rem;align-items:flex-end;}.progress-inputs .form-group{flex:1;}
        .episode-group{display:flex;align-items:baseline;gap:.5rem;}
        .episode-group input[type="number"] {flex: 1;}
        .episode-group .season-info{color:var(--text-muted);font-size:.9rem;white-space:nowrap;}
        .episode-title-display { font-size: 0.9rem; color: var(--text-muted); text-align: center; font-style: italic; overflow: hidden; max-height: 0; opacity: 0; margin-top: 0; transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, margin-top 0.3s ease-in-out; }
        .episode-title-display.visible { max-height: 5em; opacity: 1; margin-top: 0.75rem; }
        .progress-clear-btn { background: none; border: none; color: var(--text-muted); font-size: 2rem; font-weight: bold; cursor: pointer; padding: 0.25rem; line-height: 1; margin-left: .5rem; transition: color .2s; }
        .progress-clear-btn:hover { color: var(--danger-color); }
        #seasons-header { display: flex; align-items: center; justify-content: space-between; gap: 1rem; }
        #seasons-header .form-group { flex-grow: 1; margin-bottom: 0;}
        #season-rating { font-weight: bold; }
        #episodes-list { display: flex; flex-direction: column; gap: 0.5rem; flex-grow: 1; overflow-y: auto; }
        .episode-item { position: relative; display: flex; gap: 1rem; align-items: center; padding: 0.5rem 0.5rem 0.5rem 1.25rem; background-color: #1e293b; border-radius: 8px; transition: background-color .3s, border-color .3s; }
        .episode-item.watched-indicator::before { content: ''; position: absolute; left: 5px; top: 20%; height: 60%; width: 4px; border-radius: 2px; background: linear-gradient(to top, rgba(34, 197, 94, 0.4), rgba(34, 197, 94, 0.9)); }
        .episode-number { color: var(--text-muted); font-weight: bold; width: 28px; text-align: right; flex-shrink: 0; }
        .episode-details { flex-grow: 1; min-width: 0; }
        .episode-title { font-weight: 500; font-size: 0.9rem; margin-bottom: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: white-space 0.3s, max-height 0.3s; }
.episode-item.expanded .episode-title { white-space: normal; }
        .filler-badge { display: inline-block; border: 1.5px solid var(--danger-color); color: var(--danger-color); font-size: 0.75rem; font-weight: bold; border-radius: 4px; padding: 0px 4px; margin-left: 8px; line-height: 1.2; }
        .episode-air-date { color: var(--text-muted); font-size: 0.8rem; }
        .episode-rating { text-align: right; flex-shrink: 0; }
        .episode-rating-score { font-weight: bold; font-size: 0.9rem; }
        .episode-rating-votes { font-size: 0.75rem; color: var(--text-muted); }
        #media-content { padding: 0; display: flex; flex-direction: column; height: 100%; position: relative; background-color:transparent; overflow: hidden; }
        .slider-container { position: relative; width: 100%; height:100%; margin: 0 auto; overflow: hidden; flex-grow: 1; display: flex; align-items: center; cursor: pointer;}
        .slider { display: flex; transition: transform 0.3s ease-in-out; height: 100%; }
        .media-slide { flex-shrink: 0; width: 100%; height:100%; display: flex; align-items: center; justify-content: center; background-color: #000; }
        .media-slide img { width: 100%; height: 100%; object-fit: contain; pointer-events: none;}
        .slider-nav { position: absolute; top: 50%; transform: translateY(-50%); width: 100%; display: flex; justify-content: space-between; padding: 0 .5rem; pointer-events: none; }
        .slider-nav-btn { pointer-events: all; background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 1.5rem; cursor: pointer; }
        .slider-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        #media-modal .modal-close { transform: translate(50%, -50%); top: 1rem; right: 1rem; }
        #media-content h4 { position:absolute; top: 0; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.5); color: white; padding: 0.5rem 1.5rem; border-radius: 0 0 8px 8px; z-index: 5;}
        .admin-nav { display: flex; border-bottom: 1px solid #334155; margin-bottom: 1rem; }
        .admin-nav-btn { flex: 1; text-align: center; padding: 1rem; background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 1rem; font-weight: 500; border-bottom: 3px solid transparent; }
        .admin-nav-btn.active { color: var(--text-color); border-bottom-color: var(--primary-color); }
        .admin-content { display: none; } .admin-content.active { display: flex; flex-direction: column; gap: 1.5rem; padding: 0 1rem 1rem;}
        .admin-section { background-color: var(--card-color); border-radius: var(--border-radius); padding: 1.5rem; }
        .admin-section h2, .admin-section h3 { font-size: 1.5rem; margin-bottom: 1.5rem; border-bottom: 1px solid #334155; padding-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; }
        .admin-section h3 { font-size: 1.2rem; margin-top: 1rem; margin-bottom: 1rem; }
        #kp-keys-header { cursor: pointer; }
        #kp-keys-header .toggle-icon { transition: transform 0.3s; display: inline-block; }
        #kp-keys-header.collapsed .toggle-icon { transform: rotate(-90deg); }
        #kp-keys-content { overflow: hidden; max-height: 1000px; transition: max-height 0.4s ease-in-out; }
        #kp-keys-content.collapsed { max-height: 0; }
        .key-table-wrapper { max-height: 300px; overflow-y: auto; border: 1px solid #334155; border-radius: 8px;}
        .key-counter { font-size: 0.9rem; font-weight: normal; }
        .total-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 2rem; text-align: center;}
        .total-stat-item h4 { font-size: 2rem; margin: 0; } .total-stat-item p { color: var(--text-muted); margin: 0.25rem 0 0 0; }
        .stats-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; }
        .user-stats-card { background-color: #334155; border-radius: 8px; padding: 1rem; }
        .user-stats-card h3 { margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem; }
        .stat-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid #475569; }
        .stat-item:last-child { border-bottom: none; }
        .stats-bar-chart { margin-top: 1rem; }
        .bar-row { display: flex; align-items: center; margin-bottom: 0.5rem; font-size: 0.9rem; }
        .bar-label { width: 80px; text-align: right; padding-right: 0.75rem; color: var(--text-muted); }
        .bar-container { flex-grow: 1; background-color: #475569; border-radius: 4px; height: 1.2rem; display: flex; align-items: center; padding: 0 0.5rem; }
        .bar-fill { height: 100%; border-radius: 4px; transition: width 0.5s; text-align: right; padding-right: 0.25rem; color: white; font-weight: bold; font-size: 0.8rem; line-height: 1.2rem; }
        .last-actions-list { list-style: none; padding: 0; max-height: 300px; overflow-y: auto; }
        .last-actions-list li { padding: 0.75rem; background-color: #334155; border-radius: 6px; margin-bottom: 0.5rem; font-size: 0.9rem; }
        .key-management-table { width: 100%; border-collapse: collapse; }
        .key-management-table th, .key-management-table td { text-align: left; padding: 0.75rem; border-bottom: 1px solid #334155; }
        .key-management-table tr:last-child td { border-bottom: none; }
        .key-management-table th { font-size: 0.9rem; color: var(--text-muted); }
        .key-management-table td { font-size: 0.8rem; word-break: break-all; vertical-align: middle; }
        .key-delete-btn { background: none; border: none; color: var(--text-muted); font-size: 1.2rem; cursor: pointer; transition: color 0.2s; }
        .key-delete-btn:hover { color: var(--danger-color); }
        .key-status-ok { color: #22c55e; } .key-status-disabled { color: var(--danger-color); }
        .add-key-form { display: flex; gap: 0.5rem; margin-top: 1rem; align-items: stretch; }
        .add-key-form button { flex-shrink: 0; padding-left: 1rem; padding-right: 1rem; margin-top: 0;}
        #add-key-form .form-submit-btn { width: auto; margin-top: 0; }
        .db-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
        .db-actions .form-submit-btn { margin-top: 0; }
        .switch-container { display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; padding: 0.5rem 0; border-bottom: 1px solid #334155;}
        .switch-container:last-child { border-bottom: none; }
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider.round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #475569; transition: .4s; border-radius: 24px; }
        .slider.round:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider.round { background-color: var(--primary-color); }
        input:checked + .slider.round:before { transform: translateX(20px); }
        .country-filter-toggle { color: var(--text-muted); cursor: pointer; text-align: center; padding: 0.5rem; border-radius: 8px; transition: background-color .2s; margin-top: 0.5rem; }
        .country-filter-toggle:hover { background-color: #334155; }
        .country-filter-toggle .arrow { display: inline-block; transition: transform .3s; }
        .country-filter-toggle.expanded .arrow { transform: rotate(180deg); }
        .country-filter-collapsible { max-height: 0; overflow: hidden; transition: max-height .4s ease-in-out; }
        .country-filter-collapsible.expanded { max-height: 500px; }
        input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0;}input[type=number]{-moz-appearance:textfield;}
        .import-form { display: flex; flex-direction: column; gap: 0.5rem; }
        .import-form input[type="file"] { background-color: #334155; padding: 0.5rem; border-radius: 8px; }
        .import-form button { margin-top: 0.5rem; }

        .box-office-line { display: flex; align-items: center; gap: 0.5rem; }
        .box-office-line.clickable { cursor: pointer; }
        .status-indicator { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
        .box-office-numbers { color: var(--text-muted); font-weight: normal; font-size: 0.9rem; white-space: nowrap; overflow-wrap: break-word; }
        .box-office-numbers .separator { margin: 0 0.25rem; }

        #search-suggestions {
            display: none;
            background-color: var(--card-color);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #334155;
            margin-bottom: 1.5rem;
        }
        .suggestion-item { display: flex; align-items: center; padding: 0.4rem 0.5rem; cursor: pointer; border-bottom: 1px solid #334155; }
        .suggestion-item:last-child { border-bottom: none; }
        .suggestion-item:hover { background-color: #334155; }
        .suggestion-poster { width: 30px; height: 45px; object-fit: cover; border-radius: 4px; margin-right: 0.75rem; flex-shrink: 0; background-color: #334155;}
        .suggestion-details { display: flex; flex-direction: column; min-width: 0; }
        .suggestion-title { font-weight: 500; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .suggestion-year { font-size: 0.8rem; color: var(--text-muted); }

        #episode-search-toggle { cursor: pointer; font-size: 1.6rem; transition: transform 0.3s, opacity 0.3s; opacity: 0.7; background: none; border: none; color: var(--text-color); padding: 0.25rem; }
        #episode-search-toggle:hover { opacity: 1; transform: scale(1.1); }
        #episode-search-toggle.expanded { transform: rotate(180deg); }
        #episode-search-container { overflow: hidden; max-height: 0; transition: max-height 0.3s ease-in-out, margin-top 0.3s ease-in-out, padding-bottom 0.3s ease-in-out; }
        #episode-search-container.expanded { max-height: 100px; margin-top: 1rem; padding-bottom: 0.5rem; }
        #episode-search-controls { display: flex; gap: 0.5rem; align-items: center; }
        .episode-item.highlighted { background-color: var(--primary-color) !important; border-color: var(--primary-color) !important; }
        .ai-toast-notification { position: absolute; bottom: 1.5rem; right: 1.5rem; background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(5px); color: var(--text-color); padding: 0.75rem 1rem; border-radius: 8px; z-index: 1200; opacity: 0; transition: opacity 0.3s; pointer-events: none; max-width: 80%; }
        .ai-toast-notification.visible { opacity: 1; }
        /* [НОВОЕ] Оверлей для ИИ-поиска серий */
                #episode-search-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(245, 242, 233, 0.85);
            color: var(--text-color);
            display: none; /* Скрыт по умолчанию */
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: bold;
            z-index: 10;
            border-radius: var(--border-radius);
            text-align: center;
        }
        body.light-theme #episode-search-overlay {
            background: rgba(245, 242, 233, 0.85);
        }
        body:not(.light-theme) #episode-search-overlay {
            background: rgba(15, 23, 42, 0.85);
        }
                /* [НОВОЕ] Стили для обновленного заголовка сезонов */
        #seasons-header {
            align-items: center;
        }
        #seasons-header select {
            padding: 0.5rem 2rem 0.5rem 0.75rem;
            background-color: var(--card-color);
            border: 1px solid #334155;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-color);
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='var(--select-arrow-color)'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5rem;
        }
        body.light-theme #seasons-header select {
             background-color: #f0ece0;
             border-color: #d7d0c4;
        }
        .season-header-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        #season-rating {
            font-size: 1.1rem;
            font-weight: bold;
            text-align: right;
            min-width: 60px; /* Даем немного места, чтобы не прыгал интерфейс */
        }
    </style>
</head>
<body>
    <div id="password-prompt" class="password-prompt"><div class="password-box"><h2>Вход</h2><form id="password-form" autocomplete="off"><div class="input-container"><input type="password" id="password-input" placeholder="Секретное слово" required autocomplete="new-password"><button type="button" class="input-clear-btn">&times;</button></div><button type="submit">Войти</button></form></div></div>
    <div id="admin-password-prompt" class="password-prompt"><div class="password-box"><h2>Доступ к админ-панели</h2><form id="admin-password-form" autocomplete="off"><div class="input-container"><input type="password" id="admin-password-input" placeholder="Пароль администратора" required autocomplete="new-password"></div><button type="submit">Войти</button></form></div></div>
    <div id="confirm-modal" class="modal"><div class="modal-content"><button class="modal-close">&times;</button><h2 id="confirm-title">Подтверждение</h2><p id="confirm-message"></p><div id="confirm-buttons"><button id="confirm-no" class="form-submit-btn danger" style="background-color: var(--text-muted);">Нет</button><button id="confirm-yes" class="form-submit-btn">Да</button></div></div></div>
    <div id="message-modal" class="modal"><div class="modal-content"><h2 id="message-title">Уведомление</h2><p id="message-text"></p><div id="message-buttons"><button id="message-ok" class="form-submit-btn">OK</button></div></div></div>
    <header><h1><span id="popcorn-btn">🍿</span>КиноМакКат</h1><p id="subtitle-text"></p></header>
    <nav><button class="tab-button active" data-tab="search-view" title="Поиск">🔎</button><button class="tab-button" data-tab="ratings-view" title="Оценки">🌟</button><button class="tab-button" data-tab="plans-view" title="Планы">🎬</button><button class="tab-button" data-tab="admin-view" title="Админка" id="admin-tab-btn" style="display: none;">📊</button></nav>
    <main>
        <div id="search-view" class="view active">
            <div id="filmography-filters">
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="filmography-sort">Сортировка</label>
                        <select id="filmography-sort">
                            <option value="popularity">По популярности</option>
                            <option value="newest">Сначала новые</option>
                            <option value="oldest">Сначала старые</option>
                        </select>
                    </div>
                     <div class="filter-group">
                        <label for="filmography-type">Тип</label>
                        <select id="filmography-type">
                            <option value="all">Все</option>
                            <option value="movie">Фильмы</option>
                            <option value="tv">Сериалы</option>
                        </select>
                    </div>
                </div>
                 <div class="filter-row">
                    <div class="filter-group">
                        <label for="filmography-genre">Жанр</label>
                        <select id="filmography-genre">
                            <option value="any">Любой</option>
                        </select>
                    </div>
                     <div class="filter-group">
                        <label for="filmography-decade">Десятилетие</label>
                        <select id="filmography-decade">
                            <option value="any">Любое</option>
                            <option value="2020" data-start-year="2020">2020-е</option>
                            <option value="2010" data-start-year="2010">2010-е</option>
                            <option value="2000" data-start-year="2000">2000-е</option>
                            <option value="1990" data-start-year="1990">1990-е</option>
                            <option value="old" data-end-year="1989">До 1990-х</option>
                        </select>
                    </div>
                </div>
            </div>
            <!-- [ИЗМЕНЕНО] HTML-структура формы поиска для корректного отображения кнопки рандома -->
            <form id="search-form">
                <div class="search-top-row">
                    <div class="filter-group search-page">
                        <label for="type-filter-search">Тип контента</label>
                        <select id="type-filter-search">
                            <option value="multi" selected>Все</option>
                            <option value="movie" data-exclude-genre="16">Фильмы</option>
                            <option value="tv" data-exclude-genre="16,10767,10764,10763">Сериалы</option>
                            <option value="movie" data-genre="16">Мультфильмы</option>
                            <option value="tv" data-genre="16">Мультсериалы</option>
                        </select>
                    </div>
                    <button type="button" id="random-movie-btn" title="Случайный фильм/сериал">🎲</button>
                </div>
                <div class="search-controls-wrapper">
                    <div class="search-input-container">
                        <input type="text" id="search-input" placeholder="Тут пустовато" autocomplete="off">
                        <button type="button" class="input-clear-btn" id="search-clear-btn">&times;</button>
                    </div>
                    <button type="submit" id="search-button" title="Поиск по названию">🔎</button>
                    <button type="button" id="ai-search-button" title="Поиск с помощью ИИ">✨</button>
                </div>
            </form>
            <div id="search-suggestions"></div>
            <div id="movie-grid"></div>
        </div>
        <div id="ratings-view" class="view">
            <div id="ratings-filters"><div class="filter-group"><label for="type-filter-ratings">Тип контента</label><select id="type-filter-ratings"><option value="all">Все</option><option value="movie" data-exclude-genre="16">Фильмы</option><option value="tv" data-exclude-genre="16">Сериалы</option><option value="movie" data-genre="16">Мультфильмы</option><option value="tv" data-genre="16">Мультсериалы</option></select></div><div class="filter-row"><div class="filter-group"><label for="sort-filter-ratings">Сортировка</label><select id="sort-filter-ratings"><option value="newest">Сначала новые</option><option value="oldest">Сначала старые</option><option value="rating">По оценке</option></select></div><div class="filter-group"><label for="author-filter-ratings">Автор</label><select id="author-filter-ratings"><option value="all">Все</option><option value="katya">Катя</option><option value="maxim">Максим</option></select></div></div><div class="filter-group"><label for="stars-filter-ratings">Оценка</label><select id="stars-filter-ratings"><option value="all">Все</option><option value="heart">❤️ Шедевр</option><option value="rating_high" data-min="8" data-max="10">Высокие (8-10)</option><option value="rating_mid" data-min="5" data-max="7.5">Средние (5-7.5)</option><option value="rating_low" data-min="0.5" data-max="4.5">Низкие (0.5-4.5)</option><option value="poop">💩 Говно</option><option value="cross">❌ Не досмотрели</option><option value="rewatch">🔄 К пересмотру</option></select></div></div>
            <div class="list-search-container">
                <div class="search-controls-wrapper">
                    <div class="search-input-container">
                        <input type="text" id="ratings-search-input" class="list-search-input" placeholder="Поиск по оценкам...">
                        <button type="button" class="input-clear-btn">&times;</button>
                    </div>
                    <button type="button" id="ratings-search-btn" class="list-search-btn">🔎</button>
                </div>
            </div>
            <div id="rated-movies-list"></div>
        </div>
        <div id="plans-view" class="view">
             <div id="plans-filters">
                <div class="filter-row" style="grid-template-columns: 1fr; gap: .5rem;">
                    <div class="filter-group">
                        <label for="type-filter-plans">Тип контента</label>
                        <select id="type-filter-plans">
                            <option value="all">Все</option>
                            <option value="movie" data-exclude-genre="16">Фильмы</option>
                            <option value="tv" data-exclude-genre="16">Сериалы</option>
                            <option value="movie" data-genre="16">Мультфильмы</option>
                            <option value="tv" data-genre="16">Мультсериалы</option>
                        </select>
                    </div>
                </div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label for="sort-filter-plans">Сортировка</label>
                        <select id="sort-filter-plans">
                            <option value="priority">По приоритету</option>
                            <option value="newest">Сначала новые</option>
                            <option value="oldest">Сначала старые</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="author-filter-plans">Кто предложил</label>
                        <select id="author-filter-plans">
                            <option value="all">Все</option>
                            <option value="katya">Катя</option>
                            <option value="maxim">Максим</option>
                        </select>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="priority-filter-plans">Приоритет</label>
                    <select id="priority-filter-plans">
                        <option value="all">Все</option>
                        <option value="3">🥇 Высокий</option>
                        <option value="2">🥈 Средний</option>
                        <option value="1">🥉 Низкий</option>
                    </select>
                </div>
            </div>
            <div class="list-search-container">
                <div class="search-controls-wrapper">
                    <div class="search-input-container">
                        <input type="text" id="plans-search-input" class="list-search-input" placeholder="Поиск по планам...">
                        <button type="button" class="input-clear-btn">&times;</button>
                    </div>
                    <button type="button" id="plans-search-btn" class="list-search-btn">🔎</button>
                    <button type="button" id="random-plan-btn" title="Случайный из планов">🎲</button>
                </div>
            </div>
            <div id="plans-list"></div>
        </div>
        <div id="admin-view" class="view">
            <div class="admin-nav">
                <button class="admin-nav-btn active" data-tab="admin-stats">📊 Статистика</button>
                <button class="admin-nav-btn" data-tab="admin-management">🛠️ Управление</button>
            </div>
            <div id="admin-stats" class="admin-content active">
                <div class="admin-section">
                    <h2>Общая статистика</h2>
                    <div class="total-stats">
                        <div class="total-stat-item">
                            <h4 id="total-rated-stat">0</h4>
                            <p>Всего оценено</p>
                        </div>
                        <div class="total-stat-item">
                            <h4 id="total-planned-stat">0</h4>
                            <p>Всего в планах</p>
                        </div>
                    </div>
                    <div id="user-stats-container" class="stats-container"></div>
                </div>
                <div class="admin-section">
                    <h2>⚙️ Настройки</h2>
                    <div id="admin-settings-content">
                         <h3>Фильтрация контента</h3>
                         <div id="country-filters">
                         </div>
                         <div class="country-filter-collapsible-wrapper">
                             <div class="country-filter-collapsible">
                             </div>
                             <div class="country-filter-toggle">Показать/скрыть остальные <span class="arrow">▼</span></div>
                         </div>
                         <h3 style="margin-top: 2rem;">Прочее</h3>
                         <div class="switch-container">
                             <span>🚫 Выключить аниме</span>
                             <label class="switch"><input type="checkbox" id="disable-anime-switch" data-setting="disable_anime"><span class="slider round"></span></label>
                         </div>
                    </div>
                </div>
                 <div class="admin-section">
                    <h2>Последние действия</h2>
                    <ul id="last-actions-list" class="last-actions-list"></ul>
                </div>
            </div>
            <div id="admin-management" class="admin-content">
                 <div class="admin-section">
                    <h3 id="kp-keys-header">
                        Ключи Kinopoisk API
                        <span class="toggle-icon">▼</span>
                    </h3>
                    <div id="kp-keys-content">
                        <div class="key-table-wrapper">
                            <table class="key-management-table">
                                <thead><tr><th>Ключ</th><th>Запросы</th><th>Статус</th><th></th></tr></thead>
                                <tbody id="kp-keys-tbody"></tbody>
                            </table>
                        </div>
                    </div>
                    <form id="add-key-form" class="add-key-form">
                        <div class="input-container">
                            <input type="text" id="new-kp-key-input" placeholder="Новый ключ Kinopoisk..." required>
                            <button type="button" class="input-clear-btn">&times;</button>
                        </div>
                        <button type="submit" class="form-submit-btn" title="Добавить ключ">✅</button>
                    </form>
                    <h3 style="margin-top: 2rem;">Управление базой данных</h3>
                    <div class="db-actions">
                        <button id="download-ratings-btn" class="form-submit-btn">Скачать Ratings.json</button>
                        <button id="download-plans-btn" class="form-submit-btn">Скачать Plans.json</button>
                    </div>
                    <h3 style="margin-top: 2rem;">Импорт данных из JSON</h3>
                    <p style="color: var(--text-muted); font-size: 0.8rem; margin-bottom: 1rem;">ВНИМАНИЕ: Импорт полностью заменит все данные в выбранной таблице.</p>
                    <form class="import-form" data-table="ratings">
                        <label for="ratings-file">Ratings.json</label>
                        <input type="file" id="ratings-file" accept=".json" required>
                        <button type="submit" class="form-submit-btn">Импорт оценок</button>
                    </form>
                    <form class="import-form" data-table="plans" style="margin-top: 1rem;">
                        <label for="plans-file">Plans.json</label>
                        <input type="file" id="plans-file" accept=".json" required>
                        <button type="submit" class="form-submit-btn">Импорт планов</button>
                    </form>
                    <form class="import-form" data-table="kp_api_keys" style="margin-top: 1rem;">
                        <label for="kp-keys-file">KP Keys.json</label>
                        <input type="file" id="kp-keys-file" accept=".json" required>
                        <button type="submit" class="form-submit-btn">Импорт ключей КП</button>
                    </form>
                     <h3 style="margin-top: 2rem;">Прочее</h3>
                    <div class="db-actions" style="grid-template-columns: 1fr;">
                         <button id="clear-cache-btn" class="form-submit-btn danger">Очистить локальный кэш</button>
                    </div>
                </div>
            </div>
        </div>
    </main>
    <div id="movie-details-modal" class="modal">
        <div class="modal-content">
            <div class="modal-loader"><p>Загрузка...</p></div>
            <button class="modal-close">&times;</button>
            <div id="modal-body"></div>
            <form id="rating-form" style="display: none;">
                <div class="person-switcher"><button type="button" class="person-btn katya" data-person="katya">😺 Катя</button><button type="button" class="person-btn maxim" data-person="maxim">👾 Максим</button></div>
                <div class="rating-carousel-container"><div class="rating-carousel-slider"><div class="rating-slide" data-person="katya"><div class="score-display"></div><input type="range" class="score-slider" min="0" max="10" step="0.5" value="0"><div class="special-rating-input" data-special=""><span class="special-icon" data-value="heart" title="Шедевр">❤️</span><span class="special-icon" data-value="poop" title="Говно">💩</span><span class="special-icon" data-value="cross" title="Не досмотрели">❌</span><span class="special-icon" data-value="rewatch" title="Надо пересмотреть">🔄</span></div><div class="comment-container"><textarea class="comment-input" id="katya-comment" placeholder="Комментарий Кати..."></textarea><button type="button" class="comment-clear-btn">&times;</button></div></div><div class="rating-slide" data-person="maxim"><div class="score-display"></div><input type="range" class="score-slider" min="0" max="10" step="0.5" value="0"><div class="special-rating-input" data-special=""><span class="special-icon" data-value="heart" title="Шедевр">❤️</span><span class="special-icon" data-value="poop" title="Говно">💩</span><span class="special-icon" data-value="cross" title="Не досмотрели">❌</span><span class="special-icon" data-value="rewatch" title="Надо пересмотреть">🔄</span></div><div class="comment-container"><textarea class="comment-input" id="maxim-comment" placeholder="Комментарий Максима..."></textarea><button type="button" class="comment-clear-btn">&times;</button></div></div></div></div>
                <button type="submit" class="form-submit-btn">Сохранить оценку</button>
            </form>
        </div>
    </div>
    <div id="add-to-plan-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close">&times;</button>
            <h2 class="add-to-plan-title">Добавить в планы</h2>
            <form id="add-to-plan-form" data-mode="add">
                <div class="form-group"><label for="proposer-select">Предложил(а):</label><select id="proposer-select"><option value="katya">😺 Катя</option><option value="maxim">👾 Максим</option></select></div>
                <div class="form-group"><label for="priority-select">Приоритет просмотра:</label><div class="medals-input" data-priority="0"><span class="medal" data-value="1">🥉</span><span class="medal" data-value="2">🥈</span><span class="medal" data-value="3">🥇</span></div></div>
                <div class="form-group"><label for="plan-comment">Комментарий (почему стоит посмотреть):</label><textarea id="plan-comment" placeholder="Например, посоветовали друзья..."></textarea></div>
                <div class="form-group" id="plan-progress-group"><label><input type="checkbox" id="plan-progress-toggle"> Отметить прогресс</label><div class="progress-tracker" id="plan-progress-tracker"><div class="progress-inputs"><div class="form-group"><label for="plan-season-select">Сезон:</label><select id="plan-season-select"></select></div><div class="form-group"><label for="plan-episode">Серия:</label><div class="episode-group"><input type="number" id="plan-episode" pattern="\d*" min="1"><span class="season-info"></span><button type="button" class="progress-clear-btn" title="Стереть прогресс">&times;</button></div></div></div><div class="episode-title-display"></div></div></div>
                <button type="submit" class="form-submit-btn">Добавить</button>
            </form>
        </div>
    </div>
    <div id="progress-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close">&times;</button>
            <h2 class="progress-title">Изменить прогресс</h2>
            <form id="progress-form">
                <p id="progress-form-loader" class="loading-indicator" style="display: none; padding: 2rem 0; color: var(--text-muted);">Загружаю...</p>
                <div id="progress-form-content" style="visibility: hidden;">
                    <div class="progress-inputs">
                        <div class="form-group"><label for="progress-season-select">Сезон:</label><select id="progress-season-select"></select></div>
                        <div class="form-group">
                            <label for="progress-episode">Серия:</label>
                            <div class="episode-group"><input type="number" id="progress-episode" pattern="\d*" min="1"><span class="season-info"></span><button type="button" class="progress-clear-btn" title="Стереть прогресс">&times;</button></div>
                        </div>
                    </div>
                    <div class="episode-title-display"></div>
                    <button type="submit" class="form-submit-btn">Сохранить</button>
                </div>
            </form>
        </div>
    </div>
    <div id="seasons-modal" class="modal">
        <div class="modal-content">
             <button class="modal-close">&times;</button>
             <h2 id="seasons-title"></h2>
             <div id="seasons-content"></div>
        </div>
    </div>
    <div id="media-modal" class="modal"><div class="modal-content"><button class="modal-close">&times;</button><div id="media-content"></div></div></div>
    <div id="random-settings-modal" class="modal">
        <div class="modal-content">
            <button class="modal-close">&times;</button>
            <h2 id="random-settings-title">Настройки рандома</h2>
            <form id="random-settings-form">
                <div class="form-group">
                    <label for="random-duration-filter">Длительность:</label>
                    <select id="random-duration-filter">
                    </select>
                </div>
                <div class="form-group">
                    <label for="random-genre-filter">Жанр:</label>
                    <select id="random-genre-filter">
                        <option value="any" selected>Любой</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="random-decade-filter">Десятилетие:</label>
                    <select id="random-decade-filter">
                        <option value="any" selected>Любое</option>
                        <option value="2020" data-start-year="2020" data-end-year="2029">2020-е</option>
                        <option value="2010" data-start-year="2010" data-end-year="2019">2010-е</option>
                        <option value="2000" data-start-year="2000" data-end-year="2009">2000-е</option>
                        <option value="1990" data-start-year="1990" data-end-year="1999">1990-е</option>
                        <option value="1980" data-start-year="1980" data-end-year="1989">1980-е</option>
                        <option value="old" data-end-year="1979">До 1980-х</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="random-popularity-filter">Популярность:</label>
                    <select id="random-popularity-filter">
                        <option value="any" data-min-votes="100" selected>Любая</option>
                        <option value="popular" data-min-votes="500">Популярные</option>
                        <option value="very_popular" data-min-votes="2000">Очень популярные</option>
                    </select>
                </div>
                <button type="submit" class="form-submit-btn">Сохранить</button>
                <button type="reset" class="form-submit-btn danger" style="margin-top: 0.5rem; background-color: var(--text-muted);">Сбросить фильтры</button>
            </form>
        </div>
    </div>
    <button id="scroll-to-top" title="Наверх">↑</button>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script>
    // --- НАСТРОЙКИ ---
    const MYSQL_API_URL = 'api.php'; 
    const SECRET_PASSWORD = 'kuvalda';
    
    document.addEventListener('DOMContentLoaded', () => {
        const TMDB_API_KEY = 'd9241e4bce979feca67dc2cebc3278d9';
        const KINOPOISK_BASE_URL = 'https://kinopoiskapiunofficial.tech/api';
        const DEEPSEEK_API_URL = 'https://api.artemox.com/v1/chat/completions';
        const DEEPSEEK_API_KEY = 'sk-KgS4VDXVHHpyLS9pCgHp3A';
        const MY_CLOUDFLARE_WORKER_URL = 'https://maxkat.accentualz2.workers.dev/?url=';
        const API_PROXY = MY_CLOUDFLARE_WORKER_URL;
        const CORS_PROXY_URL = MY_CLOUDFLARE_WORKER_URL; 
        const ANIME_FILLER_API_URL = 'https://anime-filler.xsun.io/api/info?id=';
        const IMAGE_PROXY = 'https://wsrv.nl/?url=';
        const IMAGE_BASE_URL_W500 = 'image.tmdb.org/t/p/w500';
        const IMAGE_BASE_URL_ORIGINAL = 'image.tmdb.org/t/p/original';
        const COMMENT_WORD_LIMIT=10;const ITEMS_PER_PAGE=20;const ANIMATION_GENRE_ID=16;
        const quotes = ["Элементарно, мой дорогой Ватсон.", "May the Force be with you.", "I'll be back.", "Houston, we have a problem.", "Show me the money!", "You can't handle the truth!", "Кофе? — Только если он черный, как ночь безлунная.", "Why so serious?", "В чем сила, брат? — В деньгах вся сила, брат!", "With great power comes great responsibility.", "It's a trap!", "Winter is coming.", "Я требую продолжения банкета!"];
        
        let initialSubtitle = "";
        const movieGrid=document.getElementById('movie-grid');
        const ratedMoviesList=document.getElementById('rated-movies-list');
        const plansList=document.getElementById('plans-list');
        let moviesDataCache={},ratings={},plans={}, hiddenCountries = [], disableAnime = false, animeFillerCache = {}, randomizerSettings = {};
        let page=1,totalPages=1,isLoadingMore=false,isSearchMode=false;
        let currentFilteredRatings=[],currentFilteredPlans=[],ratedMoviesPage=1,plansPage=1;
        let ratingSortDirection='desc';
        let episodeTitleDebounce, aiSearchHistory = [], randomMoviesHistory = [], lastAiQuery = '', searchDebounceTimeout;
        let lastEpisodeAiQuery = '', lastEpisodeAiResponse = ''; // <-- ДОБАВЛЕНО
        let openModalCount = 0;
        let isModalOpening = false;
        let aiSearchCooldownEnd = 0, similarSearchCooldownEnd = 0, episodeAiSearchCooldownEnd = 0;
        let lastScrollY = 0;
        let currentCurrency = localStorage.getItem('userCurrency') || 'USD';
        let exchangeRate = null;
        let currentFilmography = [];

        // --- ЛОГИКА РАБОТЫ С MYSQL API ---
        const parseJsonFields = (dataObject) => {
            for (const id in dataObject) {
                try {
                    if (dataObject[id].movieData && typeof dataObject[id].movieData === 'string') dataObject[id].movieData = JSON.parse(dataObject[id].movieData);
                    if (dataObject[id].katya && typeof dataObject[id].katya === 'string') dataObject[id].katya = JSON.parse(dataObject[id].katya);
                    if (dataObject[id].maxim && typeof dataObject[id].maxim === 'string') dataObject[id].maxim = JSON.parse(dataObject[id].maxim);
                } catch (e) {
                    console.error(`Failed to parse JSON for ID ${id}:`, e);
                    delete dataObject[id];
                }
            }
            return dataObject;
        };

        async function loadInitialData() {
            try {
                const response = await fetch(`${MYSQL_API_URL}?action=get_all_data`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API Error ${response.status}: ${errorText}`);
                }
                const data = await response.json();
                if (data.error) throw new Error(data.error);

                ratings = parseJsonFields(data.ratings || {});
                plans = parseJsonFields(data.plans || {});
                kpApiKeysManager.keys = data.kp_api_keys || [];
                hiddenCountries = data.settings?.hidden_countries || [];
                disableAnime = data.settings?.disable_anime || false;

            } catch (e) {
                console.error("Ошибка загрузки данных с сервера:", e);
                showMessage("Не удалось загрузить данные с сервера. Проверьте консоль (F12).", "Ошибка");
            }
        }
        
        async function postToApi(action, body, isFormData = false) {
            const headers = {};
            let finalBody = body;

            if (!isFormData) {
                headers['Content-Type'] = 'application/json';
                finalBody = JSON.stringify({ ...body, password: SECRET_PASSWORD });
            } else {
                finalBody.append('password', SECRET_PASSWORD);
            }

            const response = await fetch(`${MYSQL_API_URL}?action=${action}`, {
                method: 'POST',
                headers: headers,
                body: finalBody
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({error: 'Unknown API error'}));
                throw new Error(error.error || 'API request failed');
            }
            return response.json();
        }

        const kpApiKeysManager = {
            keys: [],
            getKey() {
                const availableKeys = this.keys.filter(k => !k.disabledUntil || k.disabledUntil < Date.now()).sort((a, b) => a.count - b.count);
                if (availableKeys.length === 0) return null;
                const keyData = availableKeys[0];
                postToApi('update_kp_key', { keyId: keyData.id, updateData: { count: 1 } }).catch(console.error);
                return keyData;
            },
            async disableKey(keyString) {
                const keyData = this.keys.find(k => k.key === keyString);
                if (keyData) {
                    const disabledUntil = Date.now() + 24 * 60 * 60 * 1000;
                    keyData.disabledUntil = disabledUntil;
                    await postToApi('update_kp_key', { keyId: keyData.id, updateData: { disabledUntil }});
                    console.warn(`Kinopoisk API key ${keyString.substring(0, 8)}... disabled for 24 hours.`);
                }
            },
            async addKey(keyString) {
                if (!keyString || this.keys.some(k => k.key === keyString)) return false;
                const result = await postToApi('add_kp_key', { key: keyString });
                this.keys.push({ id: result.id, key: keyString, count: 0, disabledUntil: 0 });
                return true;
            },
            async deleteKey(keyId) {
                await postToApi('delete_kp_key', { keyId });
                this.keys = this.keys.filter(k => k.id != keyId);
            }
        };
        
        // --- ЛОГИКА ОБНОВЛЕНИЯ ВЕРСИИ ---
        async function updateApp(newVersion) {
            await showMessage('Доступна новая версия приложения. Сайт будет перезагружен для обновления.', 'Обновление');
            try {
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    for (const registration of registrations) {
                        await registration.unregister();
                    }
                }
                const cacheKeys = await caches.keys();
                await Promise.all(cacheKeys.map(key => caches.delete(key)));
                
                localStorage.setItem('app_version', newVersion);
                location.reload();
            } catch (error) {
                console.error('Failed to update app:', error);
                localStorage.setItem('app_version', newVersion);
                location.reload();
            }
        }

        async function checkVersion() {
            try {
                const response = await fetch(`version.txt?t=${Date.now()}`);
                if (!response.ok) return;
                const serverVersion = (await response.text()).trim();
                const localVersion = localStorage.getItem('app_version');

                if (serverVersion && localVersion && serverVersion !== localVersion) {
                    await updateApp(serverVersion);
                } else if (!localVersion) {
                    localStorage.setItem('app_version', serverVersion);
                }
            } catch (error) {
                console.warn('Version check failed:', error);
            }
        }
        
        async function fetchExchangeRate() {
            if (exchangeRate) return;
            try {
                const response = await fetch('https://cdn.jsdelivr.net/gh/fawazahmed0/currency-api@1/latest/currencies/usd/rub.json');
                const data = await response.json();
                exchangeRate = data.rub;
            } catch (e) {
                console.error("Failed to fetch exchange rate:", e);
                exchangeRate = 90; // Fallback
            }
        }
        
        async function init(){
            const savedTheme = sessionStorage.getItem('theme');
            if (savedTheme) document.body.classList.add(savedTheme);
            initialSubtitle = quotes[Math.floor(Math.random() * quotes.length)]; document.getElementById('subtitle-text').textContent = initialSubtitle; const mainPasswordPrompt=document.getElementById('password-prompt');if(localStorage.getItem('isVerified')==='true'){startApp();}else{mainPasswordPrompt.classList.add('visible');document.getElementById('password-form').addEventListener('submit',e=>{e.preventDefault();const input=document.getElementById('password-input');if(input.value.trim().toLowerCase()==='kuvalda'){localStorage.setItem('isVerified','true');mainPasswordPrompt.classList.remove('visible');startApp();}else{input.value='';input.style.border='1px solid var(--danger-color)';setTimeout(()=>input.style.border='1px solid #475569',1000);}});}}
        async function startApp(){
            await Promise.all([loadInitialData(), fetchExchangeRate(), populateGenreFilter('#filmography-genre')]);
            loadInitialContent();
            setupEventListeners();
            if(localStorage.getItem('isVerified')==='true'){
                document.getElementById('admin-tab-btn').style.display='flex';
            }
            checkVersion();
            setInterval(checkVersion, 5 * 60 * 1000);
        }
        
        const openModal = (modalEl) => {
            if (modalEl.classList.contains('visible')) return;
            
            if (openModalCount === 0) {
                const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
                document.body.style.paddingRight = `${scrollbarWidth}px`;
                document.body.classList.add('modal-open');
            }
            
            modalEl.classList.add('visible');
            openModalCount++;
        };

        const closeModal = (modalEl) => {
            if (!modalEl || !modalEl.classList.contains('visible')) return;
            
            modalEl.classList.remove('visible');
            openModalCount--;

            if (openModalCount <= 0) {
                document.body.classList.remove('modal-open');
                document.body.style.paddingRight = '';
            }
            
            if (openModalCount < 0) openModalCount = 0;
        };
        
        const showConfirmation = (message, title = 'Подтверждение') => {
            return new Promise(resolve => {
                const modal = document.getElementById('confirm-modal');
                modal.querySelector('#confirm-title').textContent = title;
                modal.querySelector('#confirm-message').textContent = message;
                
                const yesBtn = modal.querySelector('#confirm-yes');
                const noBtn = modal.querySelector('#confirm-no');
                const closeBtn = modal.querySelector('.modal-close');

                const cleanup = () => {
                    yesBtn.replaceWith(yesBtn.cloneNode(true));
                    noBtn.replaceWith(noBtn.cloneNode(true));
                    if(closeBtn) closeBtn.replaceWith(closeBtn.cloneNode(true));
                    closeModal(modal);
                };

                const onYes = () => { cleanup(); resolve(true); };
                const onNo = () => { cleanup(); resolve(false); };
                
                modal.querySelector('#confirm-yes').addEventListener('click', onYes, { once: true });
                modal.querySelector('#confirm-no').addEventListener('click', onNo, { once: true });
                if(closeBtn) closeBtn.addEventListener('click', onNo, { once: true });
                modal.addEventListener('click', (e) => { if (e.target === modal) onNo(); }, { once: true });

                openModal(modal);
            });
        };

        const showMessage = (message, title = 'Уведомление') => {
            return new Promise(resolve => {
                const modal = document.getElementById('message-modal');
                modal.querySelector('#message-title').textContent = title;
                modal.querySelector('#message-text').textContent = message;
                const okBtn = modal.querySelector('#message-ok');
                
                const onOk = () => {
                    okBtn.removeEventListener('click', onOk);
                    closeModal(modal);
                    resolve(true);
                };
                
                okBtn.addEventListener('click', onOk, { once: true });
                openModal(modal);
            });
        };
        
                async function fetchViaProxy(url, options = {}) {
            const fullUrl = `${API_PROXY}${encodeURIComponent(url)}`;
            try {
                const response = await fetch(fullUrl, options);
                if (!response.ok) throw new Error(`Proxy error: ${response.status} ${response.statusText}`);
                return await response.json();
            } catch (e) {
                console.error(`Fetch failed with proxy:`, e);
                throw e; 
            }
        }
        
        function buildTmdbUrl(path, params = {}) { const baseUrl = `https://api.themoviedb.org/3${path}`; const url = new URL(baseUrl); url.searchParams.append('api_key', TMDB_API_KEY); const finalParams = { language: 'ru-RU', ...params }; for (const key in finalParams) { url.searchParams.set(key, finalParams[key]); } return url.toString(); }
        async function fetchProxiedApi(url, options = {}){ try { return await fetchViaProxy(url, options); } catch(e) { return null; }}
        async function fetchKinopoiskApi(url) {
            const keyData = kpApiKeysManager.getKey();
            if (!keyData) { console.error("All Kinopoisk API keys are currently unavailable."); return null; }
            try {
                const response = await fetch(url, { headers: { 'X-API-KEY': keyData.key } });
                if (response.status === 402) { await kpApiKeysManager.disableKey(keyData.key); return fetchKinopoiskApi(url); }
                if (response.ok) return await response.json();
                if (response.status === 404) return null;
            } catch (error) { console.warn(`KP API request failed with key ${keyData.key.substring(0,4)}...:`, error); }
            return null;
        }

        const getScoreColor=score=>{if(score===null||score<=0)return'var(--text-muted)';const hue=(score/10)*120;return`hsl(${hue},70%,45%)`;};
        const formatScore=score=>(score%1===0)?score:score.toFixed(1);
        function getProxiedImageUrl(path, original = false){if(!path)return 'https://i.imgur.com/k2oTj0b.png'; const baseUrl = original ? IMAGE_BASE_URL_ORIGINAL : IMAGE_BASE_URL_W500; return`${IMAGE_PROXY}${baseUrl}${path}`;}
        function formatVoteCount(count) { if (count === undefined || count === null) return ''; if (count < 1000) return count.toString(); if (count < 1000000) return Math.floor(count / 1000) + 'K'; return Math.floor(count / 1000000) + 'M'; }
        
        const isoToFlag = isoCode => { try { return String.fromCodePoint(...isoCode.toUpperCase().split('').map(char => 0x1F1E6 + char.charCodeAt(0) - 'A'.charCodeAt(0))); } catch(e) { return ''; }};
        const getCountryFlags = countries => { if (!countries || countries.length === 0) return 'н/д'; return countries.map(c => c.iso_3166_1 ? isoToFlag(c.iso_3166_1) : '').join(' '); };
        
        function formatMovieRuntime(totalMinutes) {
            if (!totalMinutes || totalMinutes <= 0) return 'н/д';
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            let result = '';
            if (hours > 0) {
                result += `${hours} ч `;
            }
            if (minutes > 0) {
                result += `${minutes} мин`;
            }
            return result.trim();
        }

        async function getSeriesEpisodeRuntime(tvData) {
            if (tvData.episode_run_time && tvData.episode_run_time.length > 0) {
                const avgRuntime = Math.round(tvData.episode_run_time.reduce((a, b) => a + b, 0) / tvData.episode_run_time.length);
                if (avgRuntime > 0) return avgRuntime;
            }
            if (tvData.seasons && tvData.seasons.length > 0) {
                const firstSeason = tvData.seasons.find(s => s.season_number > 0);
                if (firstSeason) {
                    try {
                        const seasonDetails = await fetchProxiedApi(buildTmdbUrl(`/tv/${tvData.id}/season/${firstSeason.season_number}`));
                        if (seasonDetails && seasonDetails.episodes && seasonDetails.episodes.length > 0) {
                            const runtimes = seasonDetails.episodes.map(ep => ep.runtime).filter(rt => rt && rt > 0);
                            if (runtimes.length > 0) {
                                const avgRuntime = Math.round(runtimes.reduce((a, b) => a + b, 0) / runtimes.length);
                                return avgRuntime > 0 ? avgRuntime : null;
                            }
                        }
                    } catch (e) {
                        console.error(`Fallback failed to get runtime for season ${firstSeason.season_number}`, e);
                        return null;
                    }
                }
            }
            return null;
        }

        const formatCurrency = (amount) => {
            const suffix = currentCurrency === 'RUB' ? '₽' : '$';
            if (amount >= 1_000_000_000) return `${(amount / 1_000_000_000).toFixed(1).replace('.0', '')} млрд ${suffix}`;
            if (amount >= 1_000_000) return `${(amount / 1_000_000).toFixed(1).replace('.0', '')} млн ${suffix}`;
            return `${amount.toLocaleString('ru-RU')} ${suffix}`;
        };

        function getBoxOfficeInnerHtml(budget, revenue) {
            const isRub = currentCurrency === 'RUB';
            const finalBudget = isRub ? budget * exchangeRate : budget;
            const finalRevenue = isRub ? revenue * exchangeRate : revenue;
            
            const ratio = revenue / budget;
            let statusColor;

            if (ratio < 1) { // Провал
                statusColor = 'var(--danger-color)';
            } else if (ratio < 2) { // Окупился
                statusColor = '#f97316'; // Orange
            } else { // Успех
                statusColor = '#22c55e'; // Green
            }

            return `<span class="status-indicator" style="background-color: ${statusColor};"></span>
                    <span class="box-office-numbers">
                        ${formatCurrency(finalRevenue)}<span class="separator">|</span>${formatCurrency(finalBudget)}
                    </span>`;
        }

        const createBoxOfficeHTML = (budget, revenue) => {
            if (!budget || !revenue || budget <= 1000 || revenue <= 1000) return '';
            
            const innerHtml = getBoxOfficeInnerHtml(budget, revenue);
            
            return `<span class="label">Сборы:</span>
                    <div class="value box-office-line clickable" data-budget="${budget}" data-revenue="${revenue}">
                        ${innerHtml}
                    </div>`;
        };

        async function getKinopoiskId(filmId) {
            const filmData = moviesDataCache[filmId];
            if (!filmData) return null;
            if (filmData.kinopoiskId) return filmData.kinopoiskId;
        
            const [mediaType, tmdbId] = filmId.split('-');
            let kinopoiskId = null;
        
            try {
                const externalIdsData = await fetchProxiedApi(buildTmdbUrl(`/${mediaType}/${tmdbId}/external_ids`));
                const imdbId = externalIdsData?.imdb_id;
                if (imdbId) {
                    const kpSearchData = await fetchKinopoiskApi(`${KINOPOISK_BASE_URL}/v2.2/films?imdbId=${imdbId}`);
                    kinopoiskId = kpSearchData?.items?.[0]?.kinopoiskId;
                }
            } catch (e) {
                console.warn(`KP search by IMDb ID failed for ${tmdbId}:`, e);
            }
        
            if (!kinopoiskId) {
                try {
                    const title = filmData.name || filmData.title;
                    const year = (filmData.release_date || filmData.first_air_date)?.substring(0, 4);
                    if (title) {
                        const searchUrl = `${KINOPOISK_BASE_URL}/v2.1/films/search-by-keyword?keyword=${encodeURIComponent(title)}`;
                        const kpSearchByTitle = await fetchKinopoiskApi(searchUrl);
        
                        if (kpSearchByTitle?.films && kpSearchByTitle.films.length > 0) {
                            let bestMatch = null;
                            if (year) {
                                bestMatch = kpSearchByTitle.films.find(item => item.year == year);
                            }
                            kinopoiskId = bestMatch?.filmId || kpSearchByTitle.films[0]?.filmId;
                        }
                    }
                } catch(e) {
                    console.warn(`KP search by title failed for "${filmData.title || filmData.name}":`, e);
                }
            }
            
            if (kinopoiskId) {
                moviesDataCache[filmId].kinopoiskId = kinopoiskId;
                return kinopoiskId;
            }
        
            return null;
        }
        const isValidTitle = (title) => title && title.trim() && !/^(episode|эпизод) \d+$/i.test(title.trim());
        async function fetchEpisodeTitle(filmId, seasonNumber, episodeNumber) { const [type, id] = filmId.split('-'); const tmdbEpisodeData = await fetchProxiedApi(buildTmdbUrl(`/tv/${id}/season/${seasonNumber}/episode/${episodeNumber}`)); if (tmdbEpisodeData && isValidTitle(tmdbEpisodeData.name)) { return tmdbEpisodeData.name; } const kinopoiskId = await getKinopoiskId(filmId); if (kinopoiskId) { const kpSeasonsData = await fetchKinopoiskApi(`${KINOPOISK_BASE_URL}/v2.2/films/${kinopoiskId}/seasons`); const kpSeason = kpSeasonsData?.items?.find(s => s.number == seasonNumber); const kpEpisode = kpSeason?.episodes?.find(ep => ep.episodeNumber == episodeNumber); const title = kpEpisode?.nameRu || kpEpisode?.nameEn; if (isValidTitle(title)) return title; } return null; }
        
        async function updateCardWithKpRating(item, cardElement) {
            if (cardElement.dataset.kpChecked) return;
            cardElement.dataset.kpChecked = "true";
            const ratingElement = cardElement.querySelector('.movie-card__rating');
            if (!ratingElement || ratingElement.classList.contains('future-release-icon')) return;
            const filmId = `${item.media_type}-${item.id}`;
            const kpRatingCacheKey = `kp_rating_v1_${filmId}`;
            const cachedRating = sessionStorage.getItem(kpRatingCacheKey);
            if(cachedRating) {
                ratingElement.innerHTML = cachedRating;
                return;
            }
            const kinopoiskId = await getKinopoiskId(filmId);
            if (!kinopoiskId) return;
            try {
                const kpData = await fetchKinopoiskApi(`${KINOPOISK_BASE_URL}/v2.2/films/${kinopoiskId}`);
                if (kpData && typeof kpData.ratingKinopoisk === 'number' && kpData.ratingKinopoisk > 0) {
                    const html = `<div style="display: flex; align-items: center; gap: 0.25rem;"><span class="vote-count">(${formatVoteCount(kpData.ratingKinopoiskVoteCount)})</span><span style="color: #ff8c00;">★ ${kpData.ratingKinopoisk.toFixed(1)}</span></div>`;
                    ratingElement.innerHTML = html;
                    sessionStorage.setItem(kpRatingCacheKey, html);
                }
            } catch (e) {
                console.error(`Failed to get KP rating for ${item.title || item.name}:`, e);
            }
        }

        async function updateCardWithPostCreditScene(item, cardElement) { const filmId = `${item.media_type}-${item.id}`; const fullData = await getFullMovieData(filmId); if (fullData && fullData.postCreditsScene) { const marker = document.createElement('div'); marker.className = 'movie-card__post-credits-scene'; marker.innerHTML = '👁️‍🗨️'; cardElement.querySelector('.movie-card__image-container').appendChild(marker); } }
        
        async function updateCardOnGrid(filmId) { const cardInGrid = document.querySelector(`.movie-card[data-id="${filmId}"]`); if (cardInGrid) { await getFullMovieData(filmId); cardInGrid.innerHTML = createMovieCardHTML(moviesDataCache[filmId]); } }
        
        function createMovieCardHTML(i) {
            const mediaType = i.media_type;
            const fId = `${mediaType}-${i.id}`;
            const title = i.title || i.name;
            const releaseDateStr = i.release_date || i.first_air_date;
            const r = ratings[fId];
            const p = plans[fId];
            let rh = '', specialMarkerHTML = '', pcsHTML = '', addToPlanButtonHTML = '';
        
            if (!r) {
                const inPlanClass = p ? 'in-plan' : '';
                addToPlanButtonHTML = `<button class="add-to-plan-btn ${inPlanClass}" title="Добавить в планы">+</button>`;
            }
        
            if (r) {
                let p_scores = [];
                if (r.katya?.score > 0) p_scores.push(`<span class="rating-entry">К:<span class="score-badge-small" style="background-color:${getScoreColor(r.katya.score)}">${formatScore(r.katya.score)}</span></span>`);
                if (r.maxim?.score > 0) p_scores.push(`<span class="rating-entry">М:<span class="score-badge-small" style="background-color:${getScoreColor(r.maxim.score)}">${formatScore(r.maxim.score)}</span></span>`);
                if (p_scores.length > 0) rh = `<div class="movie-card__our-rating">${p_scores.join('<br>')}</div>`;
                
                const specialIcons = { heart: '❤️', poop: '💩', cross: '❌', rewatch: '🔄' };
                const katyaSpecials = (r.katya?.special || '').split(',').filter(s => s && specialIcons[s]);
                const maximSpecials = (r.maxim?.special || '').split(',').filter(s => s && specialIcons[s]);
                const allUniqueSpecials = [...new Set([...katyaSpecials, ...maximSpecials])];
                
                if (allUniqueSpecials.length > 0) {
                     specialMarkerHTML = `<div class="movie-card__special-marker">${allUniqueSpecials.map(s => `<span>${specialIcons[s]}</span>`).join('')}</div>`;
                }
            }
        
            const fullData = moviesDataCache[fId];
            if (fullData && fullData.postCreditsScene) {
                pcsHTML = `<div class="movie-card__post-credits-scene">👁️‍🗨️</div>`;
            }
        
            const poster = getProxiedImageUrl(i.poster_path);
            const isSearchTabAll = document.getElementById('search-view').classList.contains('active') && document.getElementById('type-filter-search').value === 'multi';
            let typeIconHTML = '';
            if (isSearchTabAll) {
                const isAnimated = (i.genre_ids || []).includes(ANIMATION_GENRE_ID);
                if (i.media_type === 'movie') typeIconHTML = isAnimated ? '<span title="Мультфильм">🎨</span>' : '<span title="Фильм">🎞️</span>';
                else if (i.media_type === 'tv') typeIconHTML = isAnimated ? '<span title="Мультсериал">🖌️</span>' : '<span title="Сериал">📺</span>';
            }
            const titleHTML = `<span class="movie-card__title-text">${title}</span>${typeIconHTML}`;
            
            let ratingAndVotesHTML;
            const releaseDateObj = releaseDateStr ? new Date(releaseDateStr) : null;
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const isFutureRelease = releaseDateObj && releaseDateObj > today;
            const isUnconfirmedRelease = !releaseDateStr && !(i.overview && i.overview.trim() !== '') && !(i.genre_ids && i.genre_ids.length > 0);

            if (isFutureRelease || isUnconfirmedRelease) {
                ratingAndVotesHTML = `<span class="movie-card__rating future-release-icon">⏳</span>`;
            } else {
                const kpRatingCacheKey = `kp_rating_v1_${fId}`;
                const cachedRating = sessionStorage.getItem(kpRatingCacheKey);
                ratingAndVotesHTML = cachedRating ? cachedRating : `<span class="movie-card__rating"><span class="vote-count">(${formatVoteCount(i.vote_count)})</span><span>★ ${i.vote_average.toFixed(1)}</span></span>`;
            }

            return `<div class="movie-card__image-container">
                        <img src="${poster}" alt="${title}" class="movie-card__poster" loading="lazy">
                        ${addToPlanButtonHTML}
                        ${rh}
                        ${specialMarkerHTML}
                        ${pcsHTML}
                    </div>
                    <div class="movie-card__info">
                        <div><h3 class="movie-card__title">${titleHTML}</h3></div>
                        <div class="movie-card__details">
                            <span>${releaseDateStr ? releaseDateStr.substring(0, 4) : 'н/д'}</span>
                            ${ratingAndVotesHTML}
                        </div>
                    </div>`;
        }
        
        function displayMovies(d, clearGrid = true, container = movieGrid) {
            if (clearGrid) container.innerHTML = '';
            
            const moviesToFilter = (d.results || []).filter(m => {
                if (!m) return false;
                const hasPoster = !!m.poster_path;
                const hasOverview = m.overview && m.overview.trim() !== '';
                const hasDate = !!(m.release_date || m.first_air_date);
                const hasGenres = m.genre_ids && m.genre_ids.length > 0;
                const isRussianShort = m.overview && m.overview.toLowerCase().includes('russian short');
                return (hasPoster || hasOverview || hasDate || hasGenres) && !isRussianShort;
            });

            const moviesToDisplay = moviesToFilter.filter(m => {
                if (!m.origin_country || m.origin_country.length === 0) return true;
        
                const isJapanese = m.origin_country.includes('JP');
                const isAnimeSeries = m.media_type === 'tv' && m.genre_ids?.includes(ANIMATION_GENRE_ID);
        
                if (disableAnime && isJapanese && isAnimeSeries) {
                    return false;
                }
        
                for (const country of m.origin_country) {
                    if (hiddenCountries.includes(country)) {
                        if (country === 'JP') {
                            if (isAnimeSeries) {
                                continue; 
                            } else {
                                return false; 
                            }
                        } else {
                            return false;
                        }
                    }
                }
                
                return true;
            });

            const query = document.getElementById('search-input').value.trim();
            if (moviesToDisplay.length === 0 && clearGrid) {
                if (isFilmographyMode()) {
                     container.innerHTML = `<p class="loading-indicator">Для этого актера нет работ, соответствующих фильтрам.</p>`;
                } else if (isSearchMode && query) {
                    container.innerHTML = `<div class="no-results-message"><p>Ничего не найдено по запросу «<span class="query-text">${query}</span>».</p><p>Попробуйте другие ключевые слова или найдите в Google.</p><a href="https://www.google.com/search?q=${encodeURIComponent(query)}" target="_blank" class="google-search-link"><span>🔍</span> Искать в Google</a></div>`;
                } else {
                    container.innerHTML = `<p class="loading-indicator">Тут пустовато...</p>`;
                }
                return;
            }

            moviesToDisplay.forEach(i => {
                if (!i || (!i.title && !i.name) || !i.media_type || !['movie', 'tv'].includes(i.media_type)) return;
                const fId = `${i.media_type}-${i.id}`;
                if (document.querySelector(`.movie-card[data-id="${fId}"]`)) {
                    return;
                }
                moviesDataCache[fId] = { ...moviesDataCache[fId], ...i };
                const c = document.createElement('div');
                c.className = 'movie-card';
                c.dataset.id = fId;
                c.innerHTML = createMovieCardHTML(i);
                container.appendChild(c);
                updateCardWithKpRating(i, c);
                updateCardWithPostCreditScene(i, c);
            });
        }
        async function getFullMovieData(filmId) {
            if (moviesDataCache[filmId]?.fullCreditsLoaded) return moviesDataCache[filmId];
            let [type, id] = filmId.split('-');

            // Запрос №1: Основные данные
            const movieUrl = buildTmdbUrl(`/${type}/${id}`, { append_to_response: 'keywords,external_ids,images', include_image_language: 'ru,null' });

            // Запрос №2: Выбираем ПРАВИЛЬНЫЙ метод для получения кредитов
            let creditsUrl;
            if (type === 'tv') {
                // Для сериалов используем aggregate_credits, чтобы получить ВСЕХ актеров
                creditsUrl = buildTmdbUrl(`/tv/${id}/aggregate_credits`);
            } else {
                // Для фильмов достаточно обычного /credits
                creditsUrl = buildTmdbUrl(`/movie/${id}/credits`);
            }

            const [data, fullCreditsData] = await Promise.all([
                fetchProxiedApi(movieUrl),
                fetchProxiedApi(creditsUrl)
            ]);

            if (!data) return null;

            if (fullCreditsData) {
                data.credits = fullCreditsData;
            }

            let hasPostCreditsScene = false;
            const keywordsList = data.keywords?.keywords || data.keywords?.results;
            if (keywordsList) {
                hasPostCreditsScene = keywordsList.some(kw => [179431, 203445].includes(kw.id));
            }

            const fullData = { ...moviesDataCache[filmId], ...data, media_type: type, postCreditsScene: hasPostCreditsScene, fullCreditsLoaded: true };
            moviesDataCache[filmId] = fullData;

            const cardElement = document.querySelector(`.movie-card[data-id="${filmId}"]`);
            if (cardElement) { updateCardWithKpRating(fullData, cardElement); }
            await getKinopoiskId(filmId);
            return fullData;
        }
        
                async function createCastHTML(credits, kpData) {
            if (!credits || !credits.cast || credits.cast.length === 0) return '';
        
            const cast = credits.cast.filter(actor => actor.profile_path); 
            const castItems = cast.map(actor => {
                const kpActor = kpData?.persons?.find(p => p.nameRu === actor.name || p.nameEn === actor.name);
                
                // Сначала ищем роль в формате для сериалов (в массиве roles), 
                // если не находим - ищем в формате для фильмов (свойство character).
                const characterName = actor.roles?.[0]?.character || actor.character;
                const character = kpActor?.description || characterName || 'н/д';

                return `
                <div class="actor-item" data-person-id="${actor.id}" data-person-name="${actor.name}">
                    <img src="${getProxiedImageUrl(actor.profile_path)}" alt="${actor.name}" class="actor-photo" loading="lazy">
                    <div class="actor-info">
                        <span class="actor-name">${actor.name}</span>
                        <span class="actor-character">${character}</span>
                    </div>
                </div>`;
            }).join('');
        
            return `
                <div class="cast-container">
                    <div class="cast-toggle">
                        <span>Актерский состав</span>
                        <span class="arrow">▼</span>
                    </div>
                    <div class="cast-list">
                        ${castItems}
                    </div>
                </div>`;
        }
        
        async function showMovieDetails(filmId, fromRatings = false){
            if (isModalOpening) return;
            isModalOpening = true;

            const modal = document.getElementById('movie-details-modal');
            const loader = modal.querySelector('.modal-loader');
            const modalBody = document.getElementById('modal-body');
            const ratingForm = document.getElementById('rating-form');
            const modalContent = modal.querySelector('.modal-content');

            // Сбрасываем позицию прокрутки списка актеров перед показом
            const castList = modal.querySelector('.cast-list');
            if (castList) castList.scrollLeft = 0;

            modalContent.scrollTop = 0;
            modalBody.innerHTML = '';
            ratingForm.style.display = 'none';
            loader.classList.remove('hidden');
            openModal(modal);

            try {
                const data = await getFullMovieData(filmId);
                if (!data) throw new Error("Failed to fetch movie data.");
                
                const kinopoiskId = await getKinopoiskId(filmId);
                let kpData = null;
                if (kinopoiskId) {
                    kpData = await fetchKinopoiskApi(`${KINOPOISK_BASE_URL}/v2.2/films/${kinopoiskId}`);
                }

                if (plans[filmId] && !plans[filmId].movieData.genres) {
                    const planUpdate = { ...plans[filmId], movieData: data };
                    await postToApi('save_plan', { filmId, planData: planUpdate });
                }
                
                const { production_countries, genres, overview, credits } = data;
                const countryFlags = getCountryFlags(production_countries);
                const genreStr = (genres && genres.length > 0) ? genres.map(i=>i.name).join(', '):'Н/Д';
                const desc = overview || 'Описание отсутствует.';
                const title = data.title||data.name;
                const releaseDateStr = data.release_date||data.first_air_date;
                const posterUrl = getProxiedImageUrl(data.poster_path);
                                let descriptionHTML;
                if (desc.length > 200) {
                    const shortText = desc.substring(0, 200) + '...';
                    descriptionHTML = `<p class="modal-description" data-short-text="${encodeURIComponent(shortText)}" data-full-text="${encodeURIComponent(desc)}">${shortText}</p>`;
                } else {
                    descriptionHTML = `<p class="modal-description">${desc}</p>`;
                }
                
                const isAnimated = (data.genres || []).some(g => g.id === ANIMATION_GENRE_ID);
                const isRated = !!ratings[filmId];
                const isPlanned = !!plans[filmId];
                
                const similarLink = `<span class="similar-link" title="Найти похожее (ИИ)" data-film-id="${filmId}" data-film-name="${title}" data-is-animated="${isAnimated}">👀</span>`;
                const planLink = `<span class="plan-link" title="Добавить в планы" data-id="${filmId}">+</span>`;

                let titleActionsHTML = '';
                if (isRated || isPlanned) {
                    titleActionsHTML = similarLink;
                } else {
                    titleActionsHTML = planLink + similarLink;
                }

                const collectionAction = data.belongs_to_collection ? `<span class="collection-link" title="Показать всю коллекцию" data-collection-id="${data.belongs_to_collection.id}" data-collection-name="${data.belongs_to_collection.name}">📎</span>` : '';
                const episodesAction = data.media_type === 'tv' ? `<span class="episodes-link" title="Список серий" data-film-id="${filmId}">🗂️</span>` : '';
                const framesAction = `<span class="frames-link" title="Кадры">🖼️</span>`;
                const googleAction = `<a href="https://www.google.com/search?q=${encodeURIComponent(title + ' ' + (releaseDateStr||'').substring(0,4))}" target="_blank" class="google-link" title="Искать в Google">🌐</a>`;
                
                let secondaryActionsHTML = `<div class="modal-secondary-actions">${collectionAction}${episodesAction}${framesAction}${googleAction}</div>`;
                
                const boxOfficeHTML = createBoxOfficeHTML(data.budget, data.revenue);
                const castHTML = await createCastHTML(credits, kpData);
                
                let durationHTML = '';
                if (data.media_type === 'movie' && data.runtime > 0) {
                    durationHTML = `<span class="label">Идёт:</span><span class="value">${formatMovieRuntime(data.runtime)}</span>`;
                } else if (data.media_type === 'tv') {
                    const avgRuntime = await getSeriesEpisodeRuntime(data);
                    if (avgRuntime) {
                       durationHTML = `<span class="label">Серия:</span><span class="value">≈ ${avgRuntime} мин</span>`;
                    }
                }

                modalBody.innerHTML = `<img src="${posterUrl}" alt="Постер" class="modal-poster-large">
                    <div class="modal-info-wrapper">
                        <div class="modal-title-row">
                            <div class="title-main-block">
                               <h2 data-id="${filmId}">${title}</h2>
                               <p>${data.original_title||data.original_name||''}</p>
                            </div>
                            <div class="title-actions">${titleActionsHTML}</div>
                        </div>
                        ${secondaryActionsHTML}
                        <div class="info-grid">
                            <span class="label">Год:</span><span class="value">${releaseDateStr?releaseDateStr.substring(0,4):'н/д'}</span>
                            <span class="label">Страна:</span><span class="value country-flags">${countryFlags}</span>
                            <span class="label">Жанр:</span><span class="value">${genreStr}</span>
                            ${durationHTML}
                            ${boxOfficeHTML}
                        </div>
                        ${descriptionHTML}
                        ${castHTML}
                    </div>`;

                
                const descriptionEl = modalBody.querySelector('.modal-description');
                if (descriptionEl && descriptionEl.dataset.fullText) {
                    descriptionEl.addEventListener('click', () => {
                        const isShort = descriptionEl.textContent.endsWith('...');
                        if (isShort) {
                            descriptionEl.textContent = decodeURIComponent(descriptionEl.dataset.fullText);
                        } else {
                            descriptionEl.textContent = decodeURIComponent(descriptionEl.dataset.shortText);
                        }
                    });
                }
                
                ratingForm.dataset.filmId = filmId;
                const personSwitcher = ratingForm.querySelector('.person-switcher');
                const submitBtn = ratingForm.querySelector('.form-submit-btn');
                const carouselContainer = ratingForm.querySelector('.rating-carousel-container');

                const releaseDateObj = releaseDateStr ? new Date(releaseDateStr) : null;
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const isFutureRelease = releaseDateObj && releaseDateObj > today;
                const isUnconfirmedRelease = !releaseDateStr && !(overview && overview.trim() !== '') && !(genres && genres.length > 0);
                
                personSwitcher.style.display = 'flex';
                carouselContainer.style.display = '';
                ratingForm.classList.remove('person-selected');
                personSwitcher.querySelector('.active')?.classList.remove('active');
                
                if (isFutureRelease || isUnconfirmedRelease) {
                    personSwitcher.style.display = 'none';
                    carouselContainer.style.display = 'none';
                    submitBtn.textContent = isUnconfirmedRelease ? 'Нет данных о выходе' : 'Фильм еще не вышел';
                    submitBtn.disabled = true;
                } else {
                    submitBtn.textContent = 'Выберите, кто ставит оценку';
                    submitBtn.disabled = true;

                    const existingRating = ratings[filmId];
                    const hasKatyaRating = existingRating?.katya && (existingRating.katya.score > 0 || existingRating.katya.comment || existingRating.katya.special);
                    const hasMaximRating = existingRating?.maxim && (existingRating.maxim.score > 0 || existingRating.maxim.comment || existingRating.maxim.special);

                    ['katya','maxim'].forEach(p=>{
                        const slide=document.querySelector(`.rating-slide[data-person="${p}"]`);
                        setupScore(p,existingRating?.[p]?.score);
                        setupSpecialRating(p,existingRating?.[p]?.special||'');
                        slide.querySelector('.comment-input').value=existingRating?.[p]?.comment||'';
                    });

                    const carouselSlider=document.querySelector('.rating-carousel-slider');
                    carouselSlider.style.transition='none';
                    carouselSlider.style.transform='translateX(0)';
                    setTimeout(() => carouselSlider.style.transition='',50);

                    if (hasKatyaRating && !hasMaximRating) {
                       personSwitcher.querySelector('.person-btn.katya').click();
                    } else if (!hasKatyaRating && hasMaximRating) {
                       personSwitcher.querySelector('.person-btn.maxim').click();
                    } else if (fromRatings && hasKatyaRating) {
                        personSwitcher.querySelector('.person-btn.katya').click();
                    } else if (fromRatings && hasMaximRating) {
                        personSwitcher.querySelector('.person-btn.maxim').click();
                    }
                }
                
                loader.classList.add('hidden');
                ratingForm.style.display = 'block';

            } catch(e) {
                console.error("Error showing movie details:", e);
                closeModal(modal);
            } finally {
                isModalOpening = false;
            }
        }
        
        const processCommentText = (text) => {
            if (!text) return '';
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">(ссылка)</a>');
        };

        const createCommentHTML = (comment, className) => {
            if (!comment) return '';
            const processedFullComment = processCommentText(comment);
            const words = comment.split(' ');

            if (words.length > COMMENT_WORD_LIMIT) {
                const shortText = words.slice(0, COMMENT_WORD_LIMIT).join(' ');
                const processedShortComment = processCommentText(shortText);
                return `<div class="${className} comment-clickable" data-state="short" data-short="${encodeURIComponent(processedShortComment)}" data-full="${encodeURIComponent(processedFullComment)}">${processedShortComment}...</div>`;
            }
            return `<div class="${className}">${processedFullComment}</div>`;
        };
        

        const getDateTimestamp = (dateValue) => {
            if (!dateValue) return 0;
            if (typeof dateValue.toDate === 'function') { return dateValue.toDate().getTime(); }
            if (typeof dateValue === 'string') { return new Date(dateValue.replace(' ', 'T') + 'Z').getTime(); }
            if (dateValue instanceof Date) { return dateValue.getTime(); }
            return 0;
        };

        function displayRatedMovies(isNewFilter=true){if(isNewFilter)ratedMoviesPage=1;const filters={sort:document.getElementById('sort-filter-ratings').value,author:document.getElementById('author-filter-ratings').value,stars:document.getElementById('stars-filter-ratings').value,type:document.getElementById('type-filter-ratings').value,genre:document.querySelector('#type-filter-ratings option:checked').dataset.genre,excludeGenre:document.querySelector('#type-filter-ratings option:checked').dataset.excludeGenre,starsEl:document.getElementById('stars-filter-ratings'),searchQuery:document.getElementById('ratings-search-input').value.trim().toLowerCase()};if(isNewFilter){let items=Object.entries(ratings);currentFilteredRatings=items.filter(([id,d])=>{if(!d.movieData||(!d.movieData.title&&!d.movieData.name))return false;const{movieData}=d;if(filters.type!=='all'){if(movieData.media_type!==filters.type)return false;const isAnimated=movieData.genre_ids?movieData.genre_ids.includes(ANIMATION_GENRE_ID):false;if(filters.genre&&!isAnimated)return false;if(filters.excludeGenre&&isAnimated)return false}const byAuthor=!filters.author||filters.author==='all'||(d.katya&&filters.author==='katya'&&(d.katya.score||d.katya.special||d.katya.comment))||(d.maxim&&filters.author==='maxim'&&(d.maxim.score||d.maxim.special||d.maxim.comment));if(!byAuthor)return false;let byStars=true;if(filters.stars&&filters.stars!=='all'){if(['heart','poop','cross','rewatch'].includes(filters.stars)){byStars=(d.katya?.special||'').includes(filters.stars)||(d.maxim?.special||'').includes(filters.stars)}else if(filters.stars.startsWith('rating_')){const min=parseFloat(filters.starsEl.options[filters.starsEl.selectedIndex].dataset.min);const max=parseFloat(filters.starsEl.options[filters.starsEl.selectedIndex].dataset.max);byStars=(d.katya?.score>=min&&d.katya?.score<=max)||(d.maxim?.score>=min&&d.maxim?.score<=max)}}if(!byStars)return false;if(filters.searchQuery){const title=(movieData.title||movieData.name||'').toLowerCase();const originalTitle=(movieData.original_title||movieData.original_name||'').toLowerCase();if(!title.includes(filters.searchQuery)&&!originalTitle.includes(filters.searchQuery))return false}return true});if(filters.sort==='rating'){const getSumScore=item=>{let total=0;['katya','maxim'].forEach(p=>{if(!item[1][p])return;if((item[1][p].special||'').includes('heart'))total+=11;if((item[1][p].special||'').includes('poop'))total-=1;if((item[1][p].special||'').includes('cross'))total-=2;if(item[1][p].score>0)total+=item[1][p].score});return total};currentFilteredRatings.sort((a,b)=>ratingSortDirection==='desc'?getSumScore(b)-getSumScore(a):getSumScore(a)-getSumScore(b))}else{currentFilteredRatings.sort((a,b)=>filters.sort==='newest'?getDateTimestamp(b[1].ratedAt)-getDateTimestamp(a[1].ratedAt):getDateTimestamp(a[1].ratedAt)-getDateTimestamp(b[1].ratedAt))}}renderPaginatedList(ratedMoviesList,currentFilteredRatings,ratedMoviesPage,([filmId,d])=>{const m=d.movieData;if(!m)return;const poster=getProxiedImageUrl(m.poster_path);const specialIcons={heart:'❤️',poop:'💩',cross:'❌',rewatch:'🔄'};const getRatingHTML=p=>{if(!d[p])return'';const score=d[p].score;const scoreBadge=score>0?`<span class="score-badge" style="background-color:${getScoreColor(score)}">${formatScore(score)}</span>`:'';const specialHtml=(d[p].special||'').split(',').filter(s=>s&&specialIcons[s]).map(s=>`<span class="special-rating-icon">${specialIcons[s]}</span>`).join('');return scoreBadge+specialHtml};const kRating=getRatingHTML('katya'),mRating=getRatingHTML('maxim');const isKatyaRated = d.katya && (d.katya.score > 0 || d.katya.comment || d.katya.special); const isMaximRated = d.maxim && (d.maxim.score > 0 || d.maxim.comment || d.maxim.special); const kH= isKatyaRated ?`<div class="rating-block rating-block--katya"><div class="person-rating"><div class="person-rating__header"><span class="rating-block__person">😺 Катя:</span>${kRating}</div>${createCommentHTML(d.katya.comment,'rating-block__comment')}</div></div>`:'';const mH= isMaximRated ?`<div class="rating-block rating-block--maxim"><div class="person-rating"><div class="person-rating__header"><span class="rating-block__person">👾 Максим:</span>${mRating}</div>${createCommentHTML(d.maxim.comment,'rating-block__comment')}</div></div>`:'';const ratedAtDate = d.ratedAt ? new Date(getDateTimestamp(d.ratedAt)) : null; const ratedAtStr = ratedAtDate ? ratedAtDate.toLocaleDateString('ru-RU') : ''; const i=document.createElement('div');i.className='rated-movie-item';i.dataset.id=filmId;i.innerHTML=`<div class="details-click-area"><div class="list-item__image-container"><img src="${poster}" alt="Постер" class="list-item__poster"></div><div class="rated-movie__details"><h3>${m.title||m.name||'Фильм'} (${(m.release_date||m.first_air_date)?(m.release_date||m.first_air_date).substring(0,4):'н/д'})</h3>${kH}${mH}<div class="rated-item-footer">Оценено: ${ratedAtStr}</div></div></div><button class="delete-btn" title="Удалить оценку">&times;</button>`;ratedMoviesList.appendChild(i)},isNewFilter)}
        function displayPlans(isNewFilter=true){if(isNewFilter)plansPage=1;const filters={sort:document.getElementById('sort-filter-plans').value,author:document.getElementById('author-filter-plans').value,priority:document.getElementById('priority-filter-plans').value,type:document.getElementById('type-filter-plans').value,genre:document.querySelector('#type-filter-plans option:checked').dataset.genre,excludeGenre:document.querySelector('#type-filter-plans option:checked').dataset.excludeGenre,searchQuery:document.getElementById('plans-search-input').value.trim().toLowerCase()};if(isNewFilter){let items=Object.entries(plans);currentFilteredPlans=items.filter(([id,d])=>{if(!d.movieData||(!d.movieData.title&&!d.movieData.name))return false;const{movieData}=d;if(filters.type!=='all'){if(movieData.media_type!==filters.type)return false;const isAnimated=movieData.genre_ids?movieData.genre_ids.includes(ANIMATION_GENRE_ID):false;if(filters.genre&&!isAnimated)return false;if(filters.excludeGenre&&isAnimated)return false}const byAuthor=!filters.author||filters.author==='all'||d.proposedBy===filters.author;if(!byAuthor)return false;const byPriority=!filters.priority||filters.priority==='all'||d.priority==filters.priority;if(!byPriority)return false;if(filters.searchQuery){const title=(movieData.title||movieData.name||'').toLowerCase();const originalTitle=(movieData.original_title||movieData.original_name||'').toLowerCase();if(!title.includes(filters.searchQuery)&&!originalTitle.includes(filters.searchQuery))return false}return true});if(filters.sort==='priority'){currentFilteredPlans.sort((a,b)=>(b[1].priority||0)-(a[1].priority||0)||(getDateTimestamp(b[1].proposedAt))-(getDateTimestamp(a[1].proposedAt)))}else{currentFilteredPlans.sort((a,b)=>filters.sort==='newest'?(getDateTimestamp(b[1].proposedAt))-(getDateTimestamp(a[1].proposedAt)):(getDateTimestamp(a[1].proposedAt))-(getDateTimestamp(b[1].proposedAt)))}}renderPaginatedList(plansList,currentFilteredPlans,plansPage,([filmId,d])=>{const m=d.movieData;if(!m)return;const poster=getProxiedImageUrl(m.poster_path);const progressHtml=(d.progress_percentage>0)?`<div class="progress-bar-wrapper"><div class="progress-bar-container"><div class="progress-bar-fill" style="width: ${d.progress_percentage}%;"></div></div><span class="progress-percentage">${d.progress_percentage}%</span></div>`:'';let progressInfoText= '';let progressInfoAttrs= `class="progress-info" data-id="${filmId}"`;if(m.media_type==='tv'){const hasEpisodeTitle = d.episode_title && d.episode_title.trim() !== '';const baseText=(d.season&&d.episode)?`С.${d.season} Э.${d.episode}`:'';if(hasEpisodeTitle){const titleWords=d.episode_title.split(' ');const fullText=`${baseText} — ${d.episode_title}`;if(titleWords.length>2&&baseText){const truncatedText=`${baseText} — ${titleWords.slice(0,2).join(' ')}...`;progressInfoText=truncatedText;progressInfoAttrs+=` data-state="truncated" data-full="${encodeURIComponent(fullText)}" data-truncated="${encodeURIComponent(truncatedText)}"`}else{progressInfoText=fullText}}else if(baseText){progressInfoText=baseText; progressInfoAttrs=`class="progress-info no-title" data-id="${filmId}"`;}}const pA=d.proposedAt?new Date(getDateTimestamp(d.proposedAt)).toLocaleDateString('ru-RU'):'';const cHtml=createCommentHTML(d.comment,'plan-block__comment'),pI=d.proposedBy==='katya'?'😺':'👾',pN=d.proposedBy==='katya'?'Катей':'Максимом',medalIcons={1:'🥉',2:'🥈',3:'🥇'},priorityIcon=d.priority>0?`<span class="priority-medal">${medalIcons[d.priority]}</span>`:'',pH=`<div class="plan-block plan-block--${d.proposedBy}"><div class="person-rating"><div class="person-rating__header">${pI} Предложено ${pN} ${priorityIcon}</div>${cHtml}</div></div><div class="plan-item-footer">${progressHtml}<div class="plan-footer__bottom-line">${progressInfoText?`<span ${progressInfoAttrs}>${progressInfoText}</span>`:'<span>&nbsp;</span>'}<span class="date-and-edit"><span>${pA}</span>${m.media_type==='tv'?`<span class="edit-progress-btn" data-id="${filmId}" title="Изменить прогресс">✏️</span>`:''}</span></div></div>`;const i=document.createElement('div');i.className='planned-movie-item';i.dataset.id=filmId; const pcsHTML = moviesDataCache[filmId]?.postCreditsScene ? `<div class="movie-card__post-credits-scene">👁️‍🗨️</div>` : ''; i.innerHTML=`<div class="details-click-area"><div class="list-item__image-container"><img src="${poster}" alt="Постер" class="list-item__poster">${pcsHTML}</div><div class="planned-movie__details"><h3>${m.title||m.name||'Фильм'} (${(m.release_date||m.first_air_date)?(m.release_date||m.first_air_date).substring(0,4):'н/д'})</h3>${pH}</div></div><button class="delete-btn" title="Удалить из планов">&times;</button>`;plansList.appendChild(i); updatePlanItemWithPostCreditScene(filmId, i);},isNewFilter)}
        
        async function updatePlanItemWithPostCreditScene(filmId, itemElement) {
            const fullData = await getFullMovieData(filmId);
            if (fullData && fullData.postCreditsScene) {
                const container = itemElement.querySelector('.list-item__image-container');
                if (container && !container.querySelector('.movie-card__post-credits-scene')) {
                     container.insertAdjacentHTML('beforeend', '<div class="movie-card__post-credits-scene">👁️‍🗨️</div>');
                }
            }
        }

        async function fetchAndProcessContent(isLoadMore = false) {
            if (isFilmographyMode()) {
                displayFilteredFilmography();
                return;
            }

            const selectedOption = document.getElementById('type-filter-search').selectedOptions[0];
            const type = selectedOption.value;
            const genre = selectedOption.dataset.genre;
            const excludeGenre = selectedOption.dataset.excludeGenre;
            const query = document.getElementById('search-input').value.trim();
        
            if (!isLoadMore) {
                document.getElementById('subtitle-text').textContent = initialSubtitle;
                movieGrid.innerHTML = `<p class="loading-indicator">Загрузка...</p>`;
                page = 1;
                totalPages = 1;
                isLoadingMore = false;
                isSearchMode = !!query;
                aiSearchHistory = [];
                exitFilmographyMode(); 
            } else {
                if (isLoadingMore || page >= totalPages) return;
                isLoadingMore = true;
                movieGrid.insertAdjacentHTML('beforeend', '<p class="loading-indicator">Загрузка...</p>');
            }
        
            let path, params = { page: page };
            if (!isSearchMode) {
                params['vote_count.gte'] = 50;
            }
            const searchType = type === 'multi' ? 'multi' : type;
        
            if (isSearchMode) {
                path = `/search/${searchType}`;
                params.query = query;
            } else {
                if (genre || excludeGenre) {
                    const discoverType = type === 'multi' ? 'movie' : type;
                    path = `/discover/${discoverType}`;
                    params.sort_by = 'popularity.desc';
                    if (genre) params.with_genres = genre;
                    if (excludeGenre) params.without_genres = excludeGenre;
                } else {
                    const trendingType = type === 'multi' ? 'all' : type;
                    path = `/trending/${trendingType}/week`;
                }
            }
        
            const url = buildTmdbUrl(path, params);
            const data = await fetchProxiedApi(url);
        
            if (isLoadMore) {
                const indicator = movieGrid.querySelector('.loading-indicator');
                if (indicator) indicator.remove();
            }
        
            if (data && data.results) {
                 if (isSearchMode) {
                    data.results.sort((a, b) => b.vote_count - a.vote_count);
                }
                
                if (['movie', 'tv'].includes(searchType) && type !== 'multi') {
                    data.results.forEach(item => { item.media_type = searchType; });
                }
        
                let finalResults = data.results;
        
                if (type !== 'multi') {
                    const isAnimatedFilter = !!genre;
                    const isNotAnimatedFilter = !!excludeGenre;
        
                    finalResults = finalResults.filter(item => {
                        if (item.media_type !== type) return false;
                        const isItemAnimated = item.genre_ids && item.genre_ids.includes(ANIMATION_GENRE_ID);
                        if (isAnimatedFilter && !isItemAnimated) return false;
                        if (isNotAnimatedFilter && isItemAnimated) return false;
                        return true;
                    });
                }
        
                totalPages = data.total_pages;
                displayMovies({ results: finalResults }, !isLoadMore);
                page++;
            } else if (!isLoadMore) {
                displayMovies({ results: [] }, true);
            }
            isLoadingMore = false;
        }

        const loadInitialContent = () => fetchAndProcessContent(false);
        const loadMoreContent = () => fetchAndProcessContent(true);
        function renderPaginatedList(listElement,items,page,renderItemFn,isNewFilter){if(isNewFilter)listElement.innerHTML='';const start=(page-1)*ITEMS_PER_PAGE,end=start+ITEMS_PER_PAGE;const pageItems=items.slice(start,end);if(items.length===0&&page===1){listElement.innerHTML=`<p class="loading-indicator">Тут пустовато...</p>`;return}pageItems.forEach(item=>renderItemFn(item))}
        
        async function setupProgressUI(form, filmId) {
            const filmData = await getFullMovieData(filmId);
            const seasonSelect = form.querySelector('select[id$="season-select"]');
            const episodeInput = form.querySelector('input[id$="episode"]');
            const seasonInfo = form.querySelector('.season-info');
            const episodeTitleDisplay = form.querySelector('.episode-title-display');

            seasonSelect.disabled = true; episodeInput.disabled = true;

            if (!filmData || filmData.media_type !== 'tv') {
                seasonInfo.textContent = "Не сериал";
                return;
            }

            seasonInfo.textContent = "Загрузка сезонов...";
            const tmdbTvDetails = await fetchProxiedApi(buildTmdbUrl(`/tv/${filmData.id}`));
            const seasonsData = tmdbTvDetails?.seasons?.filter(s => s.season_number > 0 && s.episode_count > 0);

            if (!seasonsData || seasonsData.length === 0) {
                seasonInfo.textContent = "Сезоны не найдены";
                return;
            }
            
            seasonSelect.innerHTML = '';
            seasonsData.forEach(season => {
                const option = document.createElement('option');
                option.value = season.season_number;
                option.textContent = season.name || `Сезон ${season.season_number}`;
                option.dataset.episodeCount = season.episode_count;
                seasonSelect.appendChild(option);
            });

            seasonInfo.textContent = "";
            seasonSelect.disabled = false;
            episodeInput.disabled = false;

            const updateEpisodeTitle = () => {
                clearTimeout(episodeTitleDebounce);
                episodeTitleDisplay.classList.remove('visible');
                episodeTitleDebounce = setTimeout(async () => {
                    const season = seasonSelect.value;
                    const episode = episodeInput.value;
                    if (season && episode > 0) {
                        episodeTitleDisplay.textContent = 'Загрузка названия...';
                        episodeTitleDisplay.classList.add('visible');
                        const title = await fetchEpisodeTitle(filmId, season, episode);
                        episodeTitleDisplay.textContent = title || '';
                        if (!title) episodeTitleDisplay.classList.remove('visible');
                    }
                }, 300);
            };

            const handleEpisodeInputChange = (e) => {
                const input = e.target;
                const max = parseInt(input.max, 10);
                if (!isNaN(max) && max > 0) {
                    let value = parseInt(input.value, 10);
                    if (!isNaN(value)) {
                        if (value < 1) input.value = 1;
                        else if (value > max) input.value = max;
                    }
                }
                updateEpisodeTitle();
            };
            
            const handleSeasonChange = () => {
                const selectedOption = seasonSelect.options[seasonSelect.selectedIndex];
                if (selectedOption) {
                    const episodeCount = selectedOption.dataset.episodeCount;
                    episodeInput.max = episodeCount;
                    seasonInfo.textContent = `/ ${episodeCount}`;
                }
                handleEpisodeInputChange({ target: episodeInput });
            };
            
            seasonSelect.addEventListener('change', handleSeasonChange);
            episodeInput.addEventListener('input', handleEpisodeInputChange);

            const existingPlan = plans[filmId];
            if (existingPlan?.season && seasonSelect.querySelector(`[value="${existingPlan.season}"]`)) {
                seasonSelect.value = existingPlan.season;
            } else {
                if (seasonSelect.options.length > 0) seasonSelect.selectedIndex = 0;
            }
            episodeInput.value = existingPlan?.episode || 1;
            
            handleSeasonChange();
        }

        async function openAddToPlanModal(filmId, isEdit = false, fromGrid = false) {
            const modal = document.getElementById('add-to-plan-modal');
            const form = document.getElementById('add-to-plan-form');
            const titleEl = modal.querySelector('.add-to-plan-title');
            const submitBtn = form.querySelector('.form-submit-btn');

            form.reset();
            const progressTracker = form.querySelector('#plan-progress-tracker');
            progressTracker.classList.remove('visible');
            progressTracker.querySelector('#plan-season-select').innerHTML = '';
            progressTracker.querySelector('#plan-episode').value = '';
            progressTracker.querySelector('.season-info').textContent = '';
            progressTracker.querySelector('.episode-title-display').classList.remove('visible');
            delete form.dataset.seasonsDataLoaded;

            setupMedals(0);

            if (isEdit) {
                const plan = plans[filmId];
                if (!plan) return;
                titleEl.textContent = 'Редактировать план';
                submitBtn.textContent = 'Сохранить изменения';
                form.dataset.mode = 'edit';
                form.querySelector('#proposer-select').value = plan.proposedBy;
                form.querySelector('#plan-comment').value = plan.comment || '';
                setupMedals(plan.priority || 0);
            } else {
                const filmData = await getFullMovieData(filmId);
                if(!filmData) { showMessage("Не удалось получить данные о фильме.", "Ошибка"); return; }
                const title = filmData.title||filmData.name||'Название не найдено';
                const year=(filmData.release_date||filmData.first_air_date||'').substring(0,4);
                titleEl.textContent = `${title} ${year?`(${year})`:''}`.trim();
                submitBtn.textContent = 'Добавить';
                form.dataset.mode = 'add';
            }

            form.dataset.filmId = filmId;
            form.dataset.fromGrid = fromGrid; 

            const filmData = await getFullMovieData(filmId);
            const progressGroup=document.getElementById('plan-progress-group');
            const isSeries=filmData.media_type==='tv';
            progressGroup.style.display = isSeries && !isEdit ? 'block' : 'none'; 
            
            openModal(modal);
        }

        async function openProgressModal(filmId) {
            if (isModalOpening) return;
            isModalOpening = true;
        
            const modal = document.getElementById('progress-modal');
            const form = document.getElementById('progress-form');

            form.reset();
            form.querySelector('#progress-season-select').innerHTML = '';
            form.querySelector('.season-info').textContent = '';
            form.querySelector('.episode-title-display').classList.remove('visible');
        
            const formLoader = document.getElementById('progress-form-loader');
            const formContent = document.getElementById('progress-form-content');

            try {
                const plan = plans[filmId];
                if (!plan) throw new Error("План не найден");
                
                modal.querySelector('.modal-content').scrollTop = 0;
                
                formLoader.style.display = 'block';
                formContent.style.visibility = 'hidden';
                
                openModal(modal);

                modal.querySelector('.progress-title').textContent = `Прогресс: ${plan.movieData.title || plan.movieData.name}`;
                form.dataset.filmId = filmId;

                await setupProgressUI(form, filmId);
                
                formLoader.style.display = 'none';
                formContent.style.visibility = 'visible';
            } catch (error) {
                console.error("Ошибка при открытии окна прогресса:", error);
                closeModal(modal);
            } finally {
                isModalOpening = false;
            }
        }
        
        async function calculateProgressAndTitle(form, filmData){const trackProgress=form.id==='progress-form'||form.querySelector('#plan-progress-toggle').checked;if(!trackProgress||!filmData||filmData.media_type!=='tv')return{season:null,episode:null,progress_percentage:0,episode_title:null};const seasonSelect=form.querySelector('select[id$="season-select"]');const episodeInput=form.querySelector('input[id$="episode"]');const filmId=form.dataset.filmId;const selectedSeason=parseInt(seasonSelect.value,10);const currentEpisode=parseInt(episodeInput.value,10);if(isNaN(selectedSeason)||isNaN(currentEpisode)||currentEpisode<=0)return{season:null,episode:null,progress_percentage:0,episode_title:null};const episodeTitle=await fetchEpisodeTitle(filmId,selectedSeason,currentEpisode);const url=buildTmdbUrl(`/tv/${filmData.id}`);const tvDetails=await fetchProxiedApi(url);if(!tvDetails)return{season:selectedSeason,episode:currentEpisode,progress_percentage:0,episode_title:episodeTitle};let watchedEpisodes=0;const totalSeriesEpisodes=tvDetails.number_of_episodes||0;const seasonsData=tvDetails.seasons?.filter(s=>s.season_number>0)||[];seasonsData.forEach(season=>{if(season.season_number<selectedSeason){watchedEpisodes+=season.episode_count}});watchedEpisodes+=currentEpisode;const percentage=totalSeriesEpisodes>0?(watchedEpisodes/totalSeriesEpisodes)*100:0;return{season:selectedSeason,episode:currentEpisode,progress_percentage:Math.min(100,parseFloat(percentage.toFixed(1))),episode_title:episodeTitle};}
        function setupScore(person,score){const slide=document.querySelector(`.rating-slide[data-person="${person}"]`);if(!slide)return;const display=slide.querySelector('.score-display'),slider=slide.querySelector('.score-slider');const finalScore=score===null||score===undefined?0:score;display.textContent=finalScore===0?'без оценки':formatScore(finalScore);display.classList.toggle('no-rating',finalScore===0);slider.value=finalScore;display.style.color=getScoreColor(score);}
        function setupSpecialRating(person,specialValue){const container=document.querySelector(`.rating-slide[data-person="${person}"] .special-rating-input`);if(!container)return;const specialValues=specialValue?specialValue.split(','):[];container.dataset.special=specialValue;container.querySelectorAll('.special-icon').forEach(icon=>icon.classList.toggle('selected',specialValues.includes(icon.dataset.value)))}
        function setupMedals(priority){const container=document.querySelector('.medals-input');if(!container)return;container.dataset.priority=priority;container.querySelectorAll('.medal').forEach(medal=>medal.classList.toggle('selected',medal.dataset.value==priority));}
        function toggleButtonLoading(button,isLoading,originalText='Сохранить',loadingText='Сохранение...'){if(!button)return;if(isLoading){button.disabled=true;button.textContent=loadingText;}else{button.disabled=false;button.textContent=originalText;}}
        
                function manageCooldown(button, duration, originalContent) {
            if (!button) return;
            button.disabled = true;
            let remaining = Math.ceil(duration / 1000);
            
            button.textContent = remaining; // Сразу показываем цифру

            const interval = setInterval(() => {
                remaining--;
                if (remaining > 0) {
                    button.textContent = remaining; // Обновляем цифру
                } else {
                    clearInterval(interval);
                    button.disabled = false;
                    button.innerHTML = originalContent; // Возвращаем иконку
                }
            }, 1000);
        }
        
        async function performAiSearch() {
            displaySearchSuggestions([]);
            if (Date.now() < aiSearchCooldownEnd) return;
            
            const currentQuery = document.getElementById('search-input').value.trim();
            if (!currentQuery) return;
        
            if (currentQuery.toLowerCase() !== lastAiQuery.toLowerCase()) {
                aiSearchHistory = [];
            }
            lastAiQuery = currentQuery;
        
            const aiSearchButton = document.getElementById('ai-search-button');
            const searchButton = document.getElementById('search-button');
        
            searchButton.disabled = true;
            aiSearchCooldownEnd = Date.now() + 20000;
            manageCooldown(aiSearchButton, 20000, '✨');
            
            movieGrid.innerHTML = `<p class="loading-indicator">ИИ подбирает контент...</p>`;
            isSearchMode = true;
        
            const filterSelect = document.getElementById('type-filter-search');
            const selectedOption = filterSelect.options[filterSelect.selectedIndex];
            const type = selectedOption.value, genre = selectedOption.dataset.genre, excludeGenre = selectedOption.dataset.excludeGenre;
            let typeContext = 'фильмы или сериалы';
            if (type === 'movie' && genre) { typeContext = 'полнометражные мультфильмы' } 
            else if (type === 'tv' && genre) { typeContext = 'мультсериалы' }
            else if (type === 'movie') { typeContext = 'фильмы' }
            else if (type === 'tv') { typeContext = 'сериалы' }
        
            let systemPrompt = `Ты — эксперт-кинокритик, помогающий подобрать ${typeContext} по запросу. Твоя задача — предоставить список из 5-7 РЕАЛЬНО СУЩЕСТВУЮЩИХ и ПОПУЛЯРНЫХ произведений.\n\nКлючевые правила:\n- **НЕ ВЫДУМЫВАЙ ФИЛЬМЫ.** Все названия должны быть реальными и легко находиться в базах данных типа IMDb или Кинопоиск.\n- **ВЫСОКИЕ ОЦЕНКИ:** Отдавай предпочтение известным фильмам с хорошими оценками критиков и зрителей.\n- **СТРОГИЙ ФОРМАТ:** Ответ должен быть только списком. Каждая строка в формате: "Русское название /// Original Title". Ничего лишнего: без нумерации, маркеров, вступлений или заключений.\n\nПример ответа:\nНачало /// Inception\nИнтерстеллар /// Interstellar\nЗеленая миля /// The Green Mile`;
            if (aiSearchHistory.length > 0) {
                systemPrompt += `\n\nИСКЛЮЧИ ЭТИ ФИЛЬМЫ (уже были предложены): ${aiSearchHistory.join(', ')}.`;
            }
        
            try {
                const response = await fetch(DEEPSEEK_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${DEEPSEEK_API_KEY}` },
                    body: JSON.stringify({
                        model: "deepseek-chat",
                        messages: [
                            { role: "user", content: `${systemPrompt}\n\nЗАПРОС ПОЛЬЗОВАТЕЛЯ:\n${currentQuery}` }
                        ]
                    })
                });
        
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `Ошибка API: ${response.status}`);
                }
        
                const aiData = await response.json();
                const titlesText = aiData.choices?.[0]?.message?.content;
                if(!titlesText){displayMovies({results:[]},true);return}
                
                const titles = titlesText.split('\n').map(line => {
                    const parts = line.split('///');
                    return parts.length === 2 ? { ru: parts[0].trim(), en: parts[1].trim() } : null;
                }).filter(Boolean);
        
                if(titles.length===0){displayMovies({results:[]},true);return}
                titles.forEach(t=>aiSearchHistory.push(t.ru, t.en));if(aiSearchHistory.length>50)aiSearchHistory.splice(0,aiSearchHistory.length-50);
        
                movieGrid.innerHTML=`<p class="loading-indicator">Ищу найденные фильмы в базе...</p>`;
        
                const searchPromises = titles.map(async (title) => {
                    const searchEn = await fetchProxiedApi(buildTmdbUrl(`/search/multi`,{query:title.en}));
                    if(searchEn?.results?.[0]) return searchEn.results[0];
                    const searchRu = await fetchProxiedApi(buildTmdbUrl(`/search/multi`,{query:title.ru}));
                    return searchRu?.results?.[0] || null;
                });
                
                let allMovies = (await Promise.all(searchPromises)).filter(Boolean);
        
                const isAnimatedFilter = !!genre, isNotAnimatedFilter = !!excludeGenre;
                
                const filteredMovies = allMovies.filter(item => {
                    if (type !== 'multi' && item.media_type !== type) return false;
                    const isItemAnimated = item.genre_ids?.includes(ANIMATION_GENRE_ID);
                    if (isAnimatedFilter && !isItemAnimated) return false;
                    if (isNotAnimatedFilter && isItemAnimated) return false;
                    return true;
                });
        
                const uniqueMovies=new Map();
                filteredMovies.forEach(movie=>{const filmId=`${movie.media_type}-${movie.id}`;if(!uniqueMovies.has(filmId))uniqueMovies.set(filmId,movie)});
                displayMovies({results:Array.from(uniqueMovies.values())},true);
        
            }catch(error){
                console.error("Ошибка при поиске через ИИ (Deepseek):",error);
                movieGrid.innerHTML=`<div class="no-results-message" style="grid-column: 1/-1; text-align: center;"><p>Произошла ошибка при ИИ-поиске. Попробуйте снова.<br><small>${error.message}</small></p></div>`
            }finally{
                searchButton.disabled=false;
            }
        }
        
        async function performSimilarAiSearch(filmId, filmName, isAnimated) {
            const [mediaType, id] = filmId.split('-');
            const sourceDescription = `${isAnimated ? 'мультфильм' : 'фильм'}${mediaType === 'tv' ? ' (сериал)' : ''}`;
            const targetDescription = `${mediaType === 'tv' ? (isAnimated ? 'мультсериалы' : 'сериалы') : (isAnimated ? 'мультфильмы' : 'фильмы')}`;
        
            const promptText = `Ты — эксперт-кинокритик, подбирающий похожие произведения.\nИсходное произведение: "${filmName}". Это ${sourceDescription}.\n\nПодбери 5-7 РЕАЛЬНО СУЩЕСТВУЮЩИХ и ПОПУЛЯРНЫХ ${targetDescription}, похожих на исходное по жанру, атмосфере, тематике или стилю. Отдавай предпочтение известным работам с хорошими оценками. НЕ выдумывай названия.\n\nТвой ответ должен быть только в формате списка, где каждая строка: "Русское название /// Original Title". Ничего лишнего: без нумерации, маркеров, вступлений или заключений.`;
            
            const response = await fetch(DEEPSEEK_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${DEEPSEEK_API_KEY}` },
                body: JSON.stringify({
                    model: "deepseek-chat",
                    messages: [ { role: "system", content: promptText } ]
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `Ошибка API: ${response.status}`);
            }

            const aiData = await response.json();
            const titlesText = aiData.choices?.[0]?.message?.content;
            if(!titlesText) {
                displayMovies({results:[]}, true);
                return;
            }

            const titles = titlesText.split('\n').map(line => {
                const parts = line.split('///');
                return parts.length === 2 ? { ru: parts[0].trim(), en: parts[1].trim() } : null;
            }).filter(Boolean);

            if(titles.length === 0) {
                displayMovies({results:[]}, true);
                return;
            }

            movieGrid.innerHTML = `<p class="loading-indicator">Ищу найденные фильмы в базе...</p>`;

            const searchPromises = titles.map(async (title) => {
                const searchEn = await fetchProxiedApi(buildTmdbUrl(`/search/multi`, { query: title.en }));
                if (searchEn?.results?.[0]) return searchEn.results[0];
                const searchRu = await fetchProxiedApi(buildTmdbUrl(`/search/multi`, { query: title.ru }));
                return searchRu?.results?.[0] || null;
            });

            let allMovies = (await Promise.all(searchPromises)).filter(Boolean);
            
            const filteredMovies = allMovies.filter(item => item.media_type === mediaType);

            const uniqueMovies = new Map();
            filteredMovies.forEach(movie => {
                const uniqueId = `${movie.media_type}-${movie.id}`;
                if (!uniqueMovies.has(uniqueId)) uniqueMovies.set(uniqueId, movie);
            });

            displayMovies({ results: Array.from(uniqueMovies.values()) }, true);
        }

        async function fetchSearchSuggestions(query) {
            if (query.length < 2) {
                displaySearchSuggestions([]);
                return;
            }
            const url = buildTmdbUrl('/search/multi', { query });
            const data = await fetchProxiedApi(url);
            if (data && data.results) {
                const filteredAndSorted = data.results
                    .filter(item => item.poster_path && (item.title || item.name) && ['movie', 'tv'].includes(item.media_type))
                    .sort((a, b) => {
                        const titleA = (a.title || a.name || '').toLowerCase();
                        const titleB = (b.title || b.name || '').toLowerCase();
                        const queryLower = query.toLowerCase();
                        const aStartsWith = titleA.startsWith(queryLower);
                        const bStartsWith = titleB.startsWith(queryLower);
                        if (aStartsWith && !bStartsWith) return -1;
                        if (!aStartsWith && bStartsWith) return 1;
                        return (b.popularity || 0) - (a.popularity || 0);
                    })
                    .slice(0, 5);

                filteredAndSorted.forEach(item => {
                    const filmId = `${item.media_type}-${item.id}`;
                    if (!moviesDataCache[filmId]) {
                        moviesDataCache[filmId] = item;
                    }
                });

                displaySearchSuggestions(filteredAndSorted);
            }
        }

        function displaySearchSuggestions(suggestions) {
            const container = document.getElementById('search-suggestions');
            if (suggestions.length === 0) {
                container.innerHTML = '';
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';
            container.innerHTML = suggestions.map(item => {
                const title = item.title || item.name;
                const year = (item.release_date || item.first_air_date || '').substring(0, 4);
                const filmId = `${item.media_type}-${item.id}`;
                return `
                    <div class="suggestion-item" data-id="${filmId}">
                        <img src="${getProxiedImageUrl(item.poster_path)}" class="suggestion-poster" loading="lazy">
                        <div class="suggestion-details">
                            <span class="suggestion-title">${title}</span>
                            <span class="suggestion-year">${year || ''}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        const isFilmographyMode = () => document.body.classList.contains('filmography-mode');
        
        function setupEventListeners(){
            const scrollToTopBtn=document.getElementById('scroll-to-top');
            
            const handleInfiniteScroll = () => {
                const activeView = document.querySelector('.view.active');
                if (!activeView || isLoadingMore || isFilmographyMode()) return;
            
                if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 500) {
                    if (activeView.id === 'search-view') {
                         loadMoreContent();
                    } else if (activeView.id === 'ratings-view') {
                        if ((ratedMoviesPage * ITEMS_PER_PAGE) < currentFilteredRatings.length) {
                            ratedMoviesPage++;
                            displayRatedMovies(false);
                        }
                    } else if (activeView.id === 'plans-view') {
                         if ((plansPage * ITEMS_PER_PAGE) < currentFilteredPlans.length) {
                            plansPage++;
                            displayPlans(true);
                        }
                    }
                }
            };

            window.addEventListener('scroll',()=>{ scrollToTopBtn.classList.toggle('visible',window.scrollY>300); handleInfiniteScroll(); });
            scrollToTopBtn.addEventListener('click',()=>window.scrollTo({top:0, behavior: 'smooth'}));
            
            document.querySelectorAll('.tab-button').forEach(t=>t.addEventListener('click', async e=>{
                const target = e.currentTarget;
                const id = target.dataset.tab;

                if (target.classList.contains('active')) {
                    if (id === 'search-view') {
                        resetSearchView();
                    }
                    return;
                }
                
                document.querySelectorAll('.tab-button').forEach(b=>b.classList.remove('active'));
                target.classList.add('active');
                
                document.querySelectorAll('.view').forEach(v=>v.classList.remove('active'));
                document.getElementById(id).classList.add('active');
                
                if (id === 'ratings-view') { await loadInitialData(); displayRatedMovies(true); }
                else if (id === 'plans-view') { await loadInitialData(); displayPlans(true); }
                else if (id === 'admin-view') { await loadInitialData(); displayAdminPanelContent(); }
                else if (id === 'search-view' && isFilmographyMode()) {
                    resetSearchView();
                }
            }));

            movieGrid.addEventListener('click',e=>{const card=e.target.closest('.movie-card');if(!card)return;if(e.target.closest('.add-to-plan-btn')){e.preventDefault(); openAddToPlanModal(card.dataset.id, false, true)}else{showMovieDetails(card.dataset.id, false)}});
            
            let longPressTimer;
            let isLongPress = false;
            
            const startLongPress = (e) => {
                const planItem = e.target.closest('.planned-movie-item');
                const commentEl = e.target.closest('.plan-block__comment');
                if (!planItem || !commentEl) return;
                
                isLongPress = false;
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    if (e.cancelable) e.preventDefault();
                    const filmId = planItem.dataset.id;
                    if (filmId) {
                        openAddToPlanModal(filmId, true);
                    }
                }, 800);
            };

            const cancelLongPress = () => clearTimeout(longPressTimer);
            
            async function handleListClick(e, listType) {
                if (listType === 'planned' && isLongPress) {
                    e.preventDefault();
                    isLongPress = false;
                    return;
                }

                if (e.target.tagName === 'A' && e.target.closest('.rating-block__comment, .plan-block__comment')) {
                    e.stopPropagation();
                    return;
                }
            
                const card = e.target.closest(`.${listType}-movie-item`);
                if (!card) return;
            
                const filmId = card.dataset.id;
                const target = e.target;
                const movieName = card.querySelector('h3')?.textContent || 'фильм';
            
                if (target.closest('.delete-btn')) {
                    if (await showConfirmation(`Удалить ${movieName}?`)) {
                        const deleteBtn = target.closest('.delete-btn');
                        if (deleteBtn) deleteBtn.disabled = true;
            
                        try {
                            if (listType === 'rated') {
                                await postToApi('delete_rating', { filmId });
                                logAdminAction(`🗑️ ${movieName} удален(о) из оценок.`);
                                delete ratings[filmId];
                                displayRatedMovies(true);
                                updateCardOnGrid(filmId);
                            } else {
                                await postToApi('delete_plan', { filmId });
                                logAdminAction(`🗑️ ${movieName} удален(о) из планов.`);
                                delete plans[filmId];
                                displayPlans(true);
                                const planBtnOnSearch = document.querySelector(`.movie-card[data-id="${filmId}"] .add-to-plan-btn`);
                                if (planBtnOnSearch) planBtnOnSearch.classList.remove('in-plan');
                            }
                        } catch (err) {
                            console.error(`Ошибка удаления:`, err);
                            showMessage("Произошла ошибка, попробуйте снова.", "Ошибка");
                        } finally {
                            if (deleteBtn) deleteBtn.disabled = false;
                        }
                    }
                } else if (target.closest('.comment-clickable')) {
                    const c = target.closest('.comment-clickable');
                    const isShort = c.dataset.state === 'short';

                    if (isShort) {
                        c.innerHTML = decodeURIComponent(c.dataset.full);
                        c.dataset.state = 'full';
                    } else {
                        c.innerHTML = `${decodeURIComponent(c.dataset.short)}...`;
                        c.dataset.state = 'short';
                    }
                } else if (target.closest('.edit-progress-btn')) {
                    openProgressModal(target.closest('.edit-progress-btn').dataset.id);
                } else if (target.closest('.progress-info')) {
                    const progressInfo = target.closest('.progress-info');
                    const state = progressInfo.dataset.state;
                    if (state === 'truncated') {
                        progressInfo.textContent = decodeURIComponent(progressInfo.dataset.full);
                        progressInfo.classList.add('expanded-title');
                        progressInfo.dataset.state = 'expanded';
                    } else if (state === 'expanded') {
                        progressInfo.textContent = decodeURIComponent(progressInfo.dataset.truncated);
                        progressInfo.classList.remove('expanded-title');
                        progressInfo.dataset.state = 'truncated';
                    }
                } else {
                    showMovieDetails(filmId, listType === 'rated');
                }
            }
            
            
            ratedMoviesList.addEventListener('click', (e) => handleListClick(e, 'rated'));
            plansList.addEventListener('click', (e) => handleListClick(e, 'planned'));
            plansList.addEventListener('mousedown', startLongPress);
            plansList.addEventListener('mouseup', cancelLongPress);
            plansList.addEventListener('mouseleave', cancelLongPress);
            plansList.addEventListener('touchstart', startLongPress, { passive: false });
            plansList.addEventListener('touchend', cancelLongPress);
            plansList.addEventListener('touchcancel', cancelLongPress);

            function setupClearButton(input) {
                const container = input.closest('.search-input-container, .input-container');
                if (!container) return;
                const clearBtn = container.querySelector('.input-clear-btn');
                
                const updateVisibility = () => {
                    clearBtn.style.display = input.value.length > 0 ? 'block' : 'none';
                };

                input.addEventListener('input', updateVisibility);
                clearBtn.addEventListener('click', () => {
                    input.value = '';
                    updateVisibility();
                    input.focus();
                    if (input.id === 'search-input') { 
                        if (isFilmographyMode()) {
                            displayFilteredFilmography();
                        } else {
                            loadInitialContent(); 
                        }
                        displaySearchSuggestions([]); 
                    }
                    if (input.id === 'ratings-search-input') { displayRatedMovies(true); }
                    if (input.id === 'plans-search-input') { displayPlans(true); }
                });
                updateVisibility();
            }
            document.querySelectorAll('#search-input, .list-search-input, #new-kp-key-input').forEach(setupClearButton);
            
            const searchInput = document.getElementById('search-input');
            const suggestionsContainer = document.getElementById('search-suggestions');

                        document.getElementById('search-form').addEventListener('submit', e => {
                e.preventDefault();
                
                // 1. Отменяем любой отложенный запрос на подсказки
                clearTimeout(searchDebounceTimeout); 
                // 2. Гарантированно скрываем контейнер с подсказками
                displaySearchSuggestions([]);
                
                if (isFilmographyMode()) {
                    displayFilteredFilmography();
                } else {
                    loadInitialContent();
                }
            });

            searchInput.addEventListener('input', () => {
                clearTimeout(searchDebounceTimeout);
                if (isFilmographyMode()) {
                    displaySearchSuggestions([]);
                    return;
                }
                searchDebounceTimeout = setTimeout(() => {
                    fetchSearchSuggestions(searchInput.value.trim());
                }, 300);
            });
            
            suggestionsContainer.addEventListener('click', e => {
                const item = e.target.closest('.suggestion-item');
                if (item) {
                    const filmId = item.dataset.id;
                    if (filmId) {
                        displaySearchSuggestions([]);
                        searchInput.value = '';
                        searchInput.dispatchEvent(new Event('input'));
                        showMovieDetails(filmId);
                    }
                }
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest('#search-form') && !e.target.closest('#search-suggestions')) {
                    displaySearchSuggestions([]);
                }
            });

            document.getElementById('ai-search-button').addEventListener('click',() => performAiSearch());
            document.getElementById('type-filter-search').addEventListener('change',()=>loadInitialContent());
            
            document.getElementById('ratings-search-btn').addEventListener('click', () => displayRatedMovies(true));
            document.getElementById('plans-search-btn').addEventListener('click', () => displayPlans(true));
             document.getElementById('ratings-search-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    displayRatedMovies(true);
                }
            });
            document.getElementById('plans-search-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    displayPlans(true);
                }
            });

            
            async function openMediaModal(filmId) {
                const modal=document.getElementById('media-modal');
                const contentEl=document.getElementById('media-content');
                openModal(modal);
                contentEl.innerHTML=`<div class="slider-container"><p class="loading-indicator">Загрузка медиа...</p></div>`;
                const filmData=await getFullMovieData(filmId); if(!filmData){contentEl.innerHTML='Ошибка загрузки данных.';return;}
                const backdrops=filmData.images?.backdrops||[];
                const slides = backdrops.slice(0, 15).map(img => `<div class="media-slide"><img src="${getProxiedImageUrl(img.file_path, true)}" loading="lazy"></div>`);
                if (slides.length === 0) { contentEl.innerHTML = `<h4 style="position:static; transform:none; margin: 1.5rem auto;">Кадры</h4><p style="text-align:center;">Изображения не найдены.</p>`; return; }
                contentEl.innerHTML = `<h4>Кадры</h4><div class="slider-container"><div class="slider" id="media-slider">${slides.join('')}</div></div><div class="slider-nav"><button id="prev-slide" class="slider-nav-btn">‹</button><button id="next-slide" class="slider-nav-btn">›</button></div>`;
                const slider = document.getElementById('media-slider'); const prevBtn = modal.querySelector('#prev-slide'); const nextBtn = modal.querySelector('#next-slide'); let currentSlide = 0;
                const updateNav = () => { prevBtn.disabled = currentSlide === 0; nextBtn.disabled = currentSlide === slides.length - 1; };
                const showSlide = () => { slider.style.transform = `translateX(-${currentSlide * 100}%)`; updateNav(); };
                prevBtn.onclick = () => { if (currentSlide > 0) { currentSlide--; showSlide(); } };
                nextBtn.onclick = () => { if (currentSlide < slides.length - 1) { currentSlide++; showSlide(); } };
                document.querySelector('#media-modal .slider-container').addEventListener('click', (e) => {
                    if (e.target.classList.contains('slider-container')) {
                        closeModal(modal);
                    }
                });
                showSlide();
            }

            document.getElementById('modal-body').addEventListener('click', async e => {
    const boxOfficeLine = e.target.closest('.box-office-line.clickable');
    if (boxOfficeLine) {
        currentCurrency = (currentCurrency === 'USD') ? 'RUB' : 'USD';
        localStorage.setItem('userCurrency', currentCurrency);
        
        const budget = parseFloat(boxOfficeLine.dataset.budget);
        const revenue = parseFloat(boxOfficeLine.dataset.revenue);
        
        boxOfficeLine.innerHTML = getBoxOfficeInnerHtml(budget, revenue);
        return;
    }
    
    const castToggle = e.target.closest('.cast-toggle');
    if (castToggle) {
        castToggle.classList.toggle('expanded');
        castToggle.nextElementSibling.classList.toggle('expanded');
        return;
    }
    
    const actorItem = e.target.closest('.actor-item');
                if (actorItem) {
                    const personId = actorItem.dataset.personId;
                    const personName = actorItem.dataset.personName;
                    showActorFilmography(personId, personName);
                    return;
                }


                const infoWrapper = e.target.closest('.modal-info-wrapper');
                if (!infoWrapper) return;
                
                let target = e.target.closest('span, a');
                if(!target && e.target.closest('.title-actions')) { // For clicks inside the action column but not on the icon itself
                    target = e.target.closest('.title-actions').querySelector('span, a');
                }
                if (!target) return;

                const filmId = infoWrapper.querySelector('[data-id]')?.dataset.id || target.dataset.filmId;
                if (!filmId) return;
                
                if (target.classList.contains('episodes-link')) {
                    openSeasonsModal(filmId);
                } else if (target.classList.contains('collection-link')) {
                    const collectionId = target.dataset.collectionId;
                    const collectionName = target.dataset.collectionName;
                    if (!collectionId) return;
                    closeModal(document.getElementById('movie-details-modal'));
                    movieGrid.innerHTML = `<p class="loading-indicator">Загрузка коллекции...</p>`;
                    document.getElementById('type-filter-search').value = 'multi';
                    document.querySelector('.tab-button[data-tab="search-view"]').click();
                    document.getElementById('search-input').value = '';
                    document.getElementById('subtitle-text').textContent = `Коллекция: ${collectionName}`;
                    exitFilmographyMode(); 
                    window.scrollTo({ top: 0, behavior: 'smooth' });

                    const url = buildTmdbUrl(`/collection/${collectionId}`);
                    const collectionData = await fetchProxiedApi(url);
                    if (collectionData && collectionData.parts) {
                        isSearchMode = true;
                        page = 1; totalPages = 1;
                        collectionData.parts.sort((a, b) => new Date(a.release_date || 0) - new Date(b.release_date || 0));
                        collectionData.parts.forEach(part => {
                            part.media_type = part.media_type || 'movie';
                        });
                        displayMovies({ results: collectionData.parts }, true);
                    }
                } else if (target.classList.contains('frames-link')) {
                    openMediaModal(filmId);
                } else if (target.classList.contains('plan-link')) {
                    openAddToPlanModal(filmId);
                } else if (target.classList.contains('similar-link')) {
                    if (Date.now() < similarSearchCooldownEnd) return;

                    const filmName = target.dataset.filmName;
                    const isAnimated = target.dataset.isAnimated === 'true';
                    
                    
                    
                    similarSearchCooldownEnd = Date.now() + 5000;
                    manageCooldown(target, 5000, '👀');
                    
                    setTimeout(() => {
                        closeModal(document.getElementById('movie-details-modal'));
                        document.querySelector('.tab-button[data-tab="search-view"]').click();
                        document.getElementById('subtitle-text').textContent = `Похожие на: ${filmName}`;
                        exitFilmographyMode(); 
                        movieGrid.innerHTML = `<p class="loading-indicator">Ищу похожее...</p>`;
                        window.scrollTo({ top: 0, behavior: 'smooth' });

                        performSimilarAiSearch(filmId, filmName, isAnimated).catch(err => {
                             console.error("Similar AI Search Error:", err);
                             movieGrid.innerHTML = `<p class="no-results-message">Не удалось найти похожие фильмы.</p>`;
                        });
                        isSearchMode = true;
                    }, 200);
                  }
            });

            document.getElementById('add-to-plan-form').addEventListener('submit',async function(e){
                e.preventDefault();
                const filmId=this.dataset.filmId; if(!filmId)return;
                const fromGrid = this.dataset.fromGrid === 'true';
                const mode = this.dataset.mode || 'add';
                const submitBtn=this.querySelector('.form-submit-btn');
                const loadingText = mode === 'edit' ? 'Сохранение...' : 'Добавление...';
                const originalText = mode === 'edit' ? 'Сохранить изменения' : 'Добавить';
                toggleButtonLoading(submitBtn,true,originalText,loadingText);
                try{
                    const filmData = await getFullMovieData(filmId);
                    if(!filmData)throw new Error("Film data not available");
                    
                    const progressData = await calculateProgressAndTitle(this, filmData);
                    const planData={
                        movieData: filmData,
                        proposedBy: this.querySelector('#proposer-select').value,
                        comment: this.querySelector('#plan-comment').value.trim(),
                        priority:parseInt(this.querySelector('.medals-input').dataset.priority||0),
                        ...progressData
                    };

                    await postToApi('save_plan', { filmId, planData });
                    
                    if (mode === 'add') {
                        logAdminAction(`${planData.proposedBy === 'katya' ? '😺' : '👾'} добавил(а) "${filmData.title || filmData.name}" в планы.`);
                    } else {
                        logAdminAction(`📝 Изменен план для "${filmData.title || filmData.name}".`);
                    }
                    
                    plans[filmId] = planData;
                    
                    closeModal(document.getElementById('add-to-plan-modal'));

                    if (fromGrid) {
                        updateCardOnGrid(filmId);
                    } else if (document.getElementById('plans-view').classList.contains('active')) {
                        displayPlans(true);
                    } else {
                        showMovieDetails(filmId);
                    }
                    
                    updateCardOnGrid(filmId);

                }catch(err){
                    console.error("Ошибка при работе с планом: ",err);showMessage("Произошла ошибка, попробуйте снова.", "Ошибка");
                }finally{
                    toggleButtonLoading(submitBtn,false,originalText);
                    this.removeAttribute('data-from-grid');
                }
            });

            document.getElementById('add-to-plan-form').querySelector('.medals-input').addEventListener('click',e=>{const medal=e.target.closest('.medal');if(medal){const container=medal.parentElement,value=medal.dataset.value;const newPriority=(container.dataset.priority===value)?0:value;setupMedals(newPriority)}});
            document.getElementById('plan-progress-toggle').addEventListener('change',async e=>{const tracker=document.getElementById('plan-progress-tracker');const form=e.target.closest('form');const isVisible=e.target.checked;tracker.classList.toggle('visible',isVisible);if(isVisible&&!form.dataset.seasonsDataLoaded){await setupProgressUI(form,form.dataset.filmId);form.dataset.seasonsDataLoaded=true;}});
            document.getElementById('progress-form').addEventListener('submit',async function(e){e.preventDefault(); const form=e.target,filmId=form.dataset.filmId;const submitBtn=form.querySelector('.form-submit-btn');const filmData=plans[filmId]?.movieData;if(!filmData)return;toggleButtonLoading(submitBtn,true,'Сохранить','Сохранение...');try{const progressData=await calculateProgressAndTitle(form, filmData);if(progressData){ const planData = { ...plans[filmId], ...progressData }; await postToApi('save_plan', { filmId, planData }); Object.assign(plans[filmId], progressData); logAdminAction(`🔄 Обновлен прогресс для "${filmData.title || filmData.name}"`); }closeModal(document.getElementById('progress-modal'));displayPlans(true); }catch(err){console.error("Ошибка обновления прогресса: ",err);showMessage("Произошла ошибка, попробуйте снова.", "Ошибка");}finally{toggleButtonLoading(submitBtn,false,'Сохранить');}});
            
            async function handleClearProgress(e) {
                const clearBtn = e.target.closest('.progress-clear-btn');
                if (!clearBtn) return;
                const form = clearBtn.closest('form');
                const filmId = form.dataset.filmId;
                if (!filmId) return;

                if (form.id === 'progress-form') {
                     const plan = plans[filmId];
                     if (!plan) return;
                     const movieName = plan.movieData.title || plan.movieData.name;

                     if(await showConfirmation(`Вы уверены, что хотите сбросить прогресс для "${movieName}"?`)) {
                         const planData = { ...plan, season: null, episode: null, progress_percentage: null, episode_title: null };
                         await postToApi('save_plan', { filmId, planData });
                         
                         delete plans[filmId].season;
                         delete plans[filmId].episode;
                         delete plans[filmId].progress_percentage;
                         delete plans[filmId].episode_title;
                         
                         logAdminAction(`🔄 Сброшен прогресс для "${movieName}".`);
                         closeModal(document.getElementById('progress-modal'));
                         displayPlans(true);
                     }
                } else { 
                     const seasonSelect=form.querySelector('select[id$="season-select"]');
                     const episodeInput=form.querySelector('input[id$="episode"]');
                     episodeInput.value='';
                     if(seasonSelect.options.length>0)seasonSelect.selectedIndex=0;
                     episodeInput.value=1;
                     seasonSelect.dispatchEvent(new Event('change',{bubbles:true}));
                }
            }

            document.getElementById('add-to-plan-modal').addEventListener('click',handleClearProgress);
            document.getElementById('progress-modal').addEventListener('click',handleClearProgress);

            const enforceNumericInput = (e) => { e.target.value = e.target.value.replace(/\D/g, ''); };
            document.getElementById('plan-episode').addEventListener('input', enforceNumericInput);
            document.getElementById('progress-episode').addEventListener('input', enforceNumericInput);
            
            document.querySelectorAll('.score-slider').forEach(slider => {
                slider.addEventListener('input', e => {
                    const slide = e.target.closest('.rating-slide');
                    const display = slide.querySelector('.score-display');
                    const score = parseFloat(e.target.value);
                    display.textContent = score === 0 ? 'без оценки' : formatScore(score);
                    display.classList.toggle('no-rating', score === 0);
                    display.style.color = getScoreColor(score);
                });
            });

            const ratingForm=document.getElementById('rating-form');const personSwitcher=document.querySelector('.person-switcher');personSwitcher.addEventListener('click',e=>{const b=e.target.closest('.person-btn');if(!b||b.classList.contains('active'))return;const form = b.closest('form');personSwitcher.querySelector('.active')?.classList.remove('active');b.classList.add('active');form.classList.add('person-selected');document.querySelector('.rating-carousel-slider').style.transform=`translateX(${b.dataset.person==='maxim'?'-50%':'0'})`;const submitBtn = form.querySelector('.form-submit-btn');submitBtn.disabled = false;submitBtn.textContent = 'Сохранить оценку';const newPerson = b.dataset.person;const newSlide = document.querySelector(`.rating-slide[data-person="${newPerson}"]`);newSlide.querySelector('.score-slider').dispatchEvent(new Event('input'));});
            ratingForm.addEventListener('click',e=>{
                const t=e.target; const slide=t.closest('.rating-slide'); if(!slide)return;
                const clearBtn=t.closest('.comment-clear-btn');
                const icon=t.closest('.special-icon');
                if(clearBtn){clearBtn.previousElementSibling.value=''}
                else if(icon){
                    const container=icon.parentElement;
                    const person=slide.dataset.person;
                    const value=icon.dataset.value;
                    const exclusiveIcons=['heart','poop','cross'];
                    
                    let specialValues = (container.dataset.special || '').split(',').filter(Boolean);

                    if (value === 'rewatch') {
                        if (specialValues.includes('rewatch')) {
                            specialValues = specialValues.filter(v => v !== 'rewatch');
                        } else {
                            specialValues.push('rewatch');
                        }
                    } else if (exclusiveIcons.includes(value)) {
                        const isCurrentlySelected = specialValues.includes(value);
                        specialValues = specialValues.filter(v => !exclusiveIcons.includes(v));
                        if (!isCurrentlySelected) {
                            specialValues.push(value);
                        }
                    }
                    setupSpecialRating(person, specialValues.join(','));
                }
            });
            ratingForm.addEventListener('submit',async function(e){
                e.preventDefault();
                const filmId=this.dataset.filmId; if(!filmId)return;
                const submitBtn=this.querySelector('.form-submit-btn');
                toggleButtonLoading(submitBtn,true,'Сохранить оценку','Сохранение...');
                try {
                    const getData=p=>{const s=document.querySelector(`.rating-slide[data-person="${p}"]`);return{score:parseFloat(s.querySelector('.score-slider').value)||0,comment:s.querySelector('.comment-input').value.trim(),special:s.querySelector('.special-rating-input').dataset.special||''};};
                    const kData=getData('katya'),mData=getData('maxim');
                    const isKatyaEmpty=!kData.score&&!kData.comment&&!kData.special;
                    const isMaximEmpty=!mData.score&&!mData.comment&&!mData.special;

                    if(isKatyaEmpty && isMaximEmpty){
                        if(ratings[filmId]){
                            await postToApi('delete_rating', { filmId });
                            const movieData = ratings[filmId].movieData;
                            delete ratings[filmId];
                            logAdminAction(`🗑️ Удалена оценка для "${movieData?.title || movieData?.name}".`);
                        }
                    } else {
                        const ratingUpdate = {};
                        if(!isKatyaEmpty) ratingUpdate.katya = kData;
                        if(!isMaximEmpty) ratingUpdate.maxim = mData;

                        if (!ratings[filmId]) {
                            const movieData = await getFullMovieData(filmId);
                            if (!movieData) throw new Error("Movie data not found for new rating.");
                            ratingUpdate.movieData = movieData;
                        } else {
                            ratingUpdate.movieData = ratings[filmId].movieData;
                        }
                        
                        await postToApi('save_rating', { filmId, ratingData: ratingUpdate });

                        const movieTitle = (ratingUpdate.movieData?.title || 'фильм');
                        const logSpecialIcons = {'heart':'❤️', 'poop':'💩', 'cross':'❌', 'rewatch':'🔄'};
                        
                        const formatLog = (personData, personName) => {
                            let text = `${personName} оценил(а) "${movieTitle}"`;
                            if (personData.score > 0) text += ` на ${personData.score}`;
                            const specialIcons = (personData.special || '').split(',').filter(Boolean).map(s => logSpecialIcons[s]);
                            if (specialIcons.length > 0) text += ` (${specialIcons.join(', ')})`;
                            logAdminAction(text);
                        }

                        if (!isKatyaEmpty) formatLog(kData, '😺 Катя');
                        if (!isMaximEmpty) formatLog(mData, '👾 Максим');
                        
                        ratings[filmId] = { ...(ratings[filmId] || {}), ...ratingUpdate };
                    }
                    
                    if(plans[filmId]){
                        await postToApi('delete_plan', { filmId });
                        delete plans[filmId];
                    }
                    
                    closeModal(document.getElementById('movie-details-modal'));
                    await updateCardOnGrid(filmId);
                    
                    const activeViewId=document.querySelector('.view.active').id;
                    if(activeViewId==='ratings-view'){
                        displayRatedMovies(true);
                    } else if (activeViewId === 'plans-view') {
                        displayPlans(true);
                    }
                }catch(err){
                    console.error("Ошибка при сохранении оценки: ",err);
                    showMessage("Произошла ошибка, попробуйте снова.", "Ошибка");
                } finally {
                    toggleButtonLoading(submitBtn,false,'Сохранить оценку');
                }
            });
            document.querySelectorAll('.modal').forEach(m=>m.addEventListener('click',e=>{if(e.target===m)closeModal(m)}));
            document.querySelectorAll('.modal-close').forEach(b=>b.addEventListener('click',()=>closeModal(b.closest('.modal'))));
            
            function handleFilterChange(e) {
                const target = e.target.closest('select');
                if (!target) return;
                const view = target.closest('.view');
                if(target.id.includes('sort-filter-ratings')){
                    const option=target.options[target.selectedIndex];
                    if(option.value === 'rating'){
                        ratingSortDirection=ratingSortDirection === 'desc' ? 'asc' : 'desc';
                        option.textContent = `По оценке ${ratingSortDirection === 'desc'?'↓':'↑'}`
                    } else {
                        document.querySelector('#sort-filter-ratings option[value="rating"]').textContent = 'По оценке';
                    }
                }
                if (view.id === 'ratings-view') { displayRatedMovies(true); } 
                else if (view.id === 'plans-view') { displayPlans(true); }
            }

            document.getElementById('ratings-filters').addEventListener('change',handleFilterChange);
            document.getElementById('plans-filters').addEventListener('change',handleFilterChange);
            document.getElementById('filmography-filters').addEventListener('change',displayFilteredFilmography);
            
            document.getElementById('random-plan-btn').addEventListener('click', showRandomPlan);
            
            document.getElementById('popcorn-btn').addEventListener('click', () => {
                document.body.classList.toggle('light-theme');
                if (document.body.classList.contains('light-theme')) {
                    sessionStorage.setItem('theme', 'light-theme');
                } else {
                    sessionStorage.removeItem('theme');
                }
            });

            setupRandomContentListeners();

            setInterval(() => {
                const icons = document.querySelectorAll('.future-release-icon');
                icons.forEach(icon => {
                    icon.textContent = icon.textContent === '⏳' ? '⌛' : '⏳';
                });
            }, 3000);

            setupAdminPanelListeners();
        }

        function setupRandomContentListeners() {
            const randomBtn = document.getElementById('random-movie-btn');
            let longPressTimer;
            let isLongPress = false;

            const startPress = (e) => {
                if (isFilmographyMode()) return;
                isLongPress = false;
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    e.preventDefault();
                    openRandomSettingsModal();
                }, 700);
            };
            const cancelPress = () => {
                clearTimeout(longPressTimer);
            };
            randomBtn.addEventListener('mousedown', startPress);
            randomBtn.addEventListener('mouseup', cancelPress);
            randomBtn.addEventListener('mouseleave', cancelPress);
            randomBtn.addEventListener('touchstart', startPress, { passive: false });
            randomBtn.addEventListener('touchend', cancelPress);
            randomBtn.addEventListener('click', (e) => {
                if (isLongPress) {
                    e.preventDefault();
                } else if (isFilmographyMode()) {
                    showRandomFilmographyItem();
                } else {
                    showRandomContent();
                }
            });

            const randomSettingsForm = document.getElementById('random-settings-form');
            randomSettingsForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const durationSelect = document.getElementById('random-duration-filter').selectedOptions[0];
                const genreSelect = document.getElementById('random-genre-filter');
                const decadeSelect = document.getElementById('random-decade-filter').selectedOptions[0];
                const popularitySelect = document.getElementById('random-popularity-filter').selectedOptions[0];
                
                randomizerSettings = {
                    minRuntime: durationSelect.dataset.minRuntime,
                    maxRuntime: durationSelect.dataset.maxRuntime,
                    value: durationSelect.value,
                    genre: genreSelect.value === 'any' ? null : genreSelect.value,
                    decadeStart: decadeSelect.dataset.startYear,
                    decadeEnd: decadeSelect.dataset.endYear,
                    decadeValue: decadeSelect.value,
                    minVotes: popularitySelect.dataset.minVotes,
                    popularityValue: popularitySelect.value,
                };
                
                closeModal(document.getElementById('random-settings-modal'));
            });

            randomSettingsForm.addEventListener('reset', () => {
                randomizerSettings = {};
                randomSettingsForm.querySelectorAll('select').forEach(s => s.selectedIndex = 0);
            });
        }

        async function populateGenreFilter(selector = '#random-genre-filter') {
            const genreSelect = document.querySelector(selector);
            if (!genreSelect || genreSelect.options.length > 1) return; 
            try {
                const data = await fetchProxiedApi(buildTmdbUrl('/genre/movie/list'));
                if (data && data.genres) {
                    data.genres.forEach(genre => {
                        const option = document.createElement('option');
                        option.value = genre.id;
                        option.textContent = genre.name;
                        genreSelect.appendChild(option);
                    });
                }
            } catch (e) { console.error("Could not populate genre filter:", e); }
        }

        async function openRandomSettingsModal() {
            await populateGenreFilter();
            const modal = document.getElementById('random-settings-modal');
            const durationSelect = document.getElementById('random-duration-filter');
            const genreSelect = document.getElementById('random-genre-filter');
            const decadeSelect = document.getElementById('random-decade-filter');
            const popularitySelect = document.getElementById('random-popularity-filter');
            
            const selectedTypeOption = document.getElementById('type-filter-search').selectedOptions[0];
            const typeValue = selectedTypeOption.value;
            const isAnimation = selectedTypeOption.dataset.genre === String(ANIMATION_GENRE_ID);
            const excludeAnimation = selectedTypeOption.dataset.excludeGenre && selectedTypeOption.dataset.excludeGenre.includes(String(ANIMATION_GENRE_ID));
            
            genreSelect.closest('.form-group').style.display = isAnimation ? 'none' : 'block';

            const animationOption = genreSelect.querySelector(`option[value="${ANIMATION_GENRE_ID}"]`);
            if (animationOption) {
                animationOption.style.display = excludeAnimation ? 'none' : 'block';
                if (excludeAnimation && genreSelect.value == ANIMATION_GENRE_ID) {
                    genreSelect.value = 'any';
                    if (randomizerSettings.genre == ANIMATION_GENRE_ID) {
                        randomizerSettings.genre = null;
                    }
                }
            }

            const isTvType = typeValue === 'tv' || (typeValue === 'multi' && Math.random() > 0.5); 
            if (isTvType) {
                durationSelect.innerHTML = `
                    <option value="any" selected>Любая</option>
                    <option value="short_series" data-max-runtime="30">Короткие (до 30 мин)</option>
                    <option value="medium_series" data-min-runtime="30" data-max-runtime="50">Средние (30-50 мин)</option>
                    <option value="long_series" data-min-runtime="50">Длинные (больше 50 мин)</option>
                `;
            } else {
                durationSelect.innerHTML = `
                    <option value="any" selected>Любая</option>
                    <option value="short" data-max-runtime="90">Меньше 1.5 часов</option>
                    <option value="medium" data-min-runtime="90" data-max-runtime="150">1.5 - 2.5 часа</option>
                    <option value="long" data-min-runtime="150">Больше 2.5 часов</option>
                `;
            }

            if(randomizerSettings.value) durationSelect.value = randomizerSettings.value;
            if(randomizerSettings.genre) genreSelect.value = randomizerSettings.genre;
            if(randomizerSettings.decadeValue) decadeSelect.value = randomizerSettings.decadeValue;
            if(randomizerSettings.popularityValue) popularitySelect.value = randomizerSettings.popularityValue;

            openModal(modal);
        }

        async function showRandomContent() {
            const button = document.getElementById('random-movie-btn');
            button.disabled = true; button.textContent = '🤔';
            try {
                const selectedOption = document.getElementById('type-filter-search').selectedOptions[0];
                const type = selectedOption.value === 'multi' ? (Math.random() < 0.65 ? 'movie' : 'tv') : selectedOption.value;
                const discoverParams = { ...randomizerSettings };
                
                discoverParams['sort_by'] = 'popularity.desc';
                if (!discoverParams.minVotes) discoverParams['vote_count.gte'] = 100;
                else {
                    discoverParams['vote_count.gte'] = discoverParams.minVotes;
                    delete discoverParams.minVotes;
                }
                
                if (!discoverParams.genre) {
                    if (selectedOption.dataset.genre) discoverParams.with_genres = selectedOption.dataset.genre;
                    if (selectedOption.dataset.excludeGenre) discoverParams.without_genres = selectedOption.dataset.excludeGenre;
                } else {
                    discoverParams.with_genres = discoverParams.genre;
                    delete discoverParams.genre;
                }

                if (discoverParams.minRuntime) { discoverParams['with_runtime.gte'] = discoverParams.minRuntime; delete discoverParams.minRuntime; }
                if (discoverParams.maxRuntime) { discoverParams['with_runtime.lte'] = discoverParams.maxRuntime; delete discoverParams.maxRuntime; }
                
                const dateKey = type === 'movie' ? 'primary_release_date' : 'first_air_date';
                if (discoverParams.decadeStart) { discoverParams[`${dateKey}.gte`] = `${discoverParams.decadeStart}-01-01`; delete discoverParams.decadeStart; }
                if (discoverParams.decadeEnd) { discoverParams[`${dateKey}.lte`] = `${discoverParams.decadeEnd}-12-31`; delete discoverParams.decadeEnd; }

                let found = false;
                for (let attempt = 0; attempt < 10; attempt++) {
                    const initialData = await fetchProxiedApi(buildTmdbUrl(`/discover/${type}`, discoverParams));
                    if (!initialData || !initialData.total_pages) continue;
                    const randomPage = Math.floor(Math.random() * Math.min(initialData.total_pages, 200)) + 1;
                    discoverParams.page = randomPage;
                    const pageData = await fetchProxiedApi(buildTmdbUrl(`/discover/${type}`, discoverParams));
                    if (!pageData || !pageData.results || pageData.results.length === 0) continue;
                    const potentialItems = pageData.results.filter(item => {
                        const filmId = `${type}-${item.id}`;
                        if (randomMoviesHistory.includes(filmId)) return false;
                        
                        if (!item.origin_country || item.origin_country.length === 0) return true;
                        const isJapanese = item.origin_country.includes('JP');
                        const isAnimeSeries = type === 'tv' && item.genre_ids?.includes(ANIMATION_GENRE_ID);
                        if (disableAnime && isJapanese && isAnimeSeries) return false;
                        if (hiddenCountries.includes('JP') && isJapanese && !isAnimeSeries) return false;
                        if (item.origin_country.some(c => c !== 'JP' && hiddenCountries.includes(c))) return false;
                        
                        return true;
                    });
                    if (potentialItems.length > 0) {
                        const randomItem = potentialItems[Math.floor(Math.random() * potentialItems.length)];
                        const filmId = `${type}-${randomItem.id}`;
                        randomMoviesHistory.push(filmId);
                        if(randomMoviesHistory.length > 100) randomMoviesHistory.shift();
                        moviesDataCache[filmId] = { ...randomItem, media_type: type };
                        showMovieDetails(filmId);
                        found = true;
                        break;
                    }
                }
                if (!found) await showMessage('Не удалось найти подходящий контент с такими фильтрами. Попробуйте смягчить их.', 'Ничего не найдено');
            } catch (e) { console.error("Error getting random content:", e); await showMessage('Произошла ошибка при поиске.', 'Ошибка'); } finally { button.disabled = false; button.textContent = '🎲'; }
        }

        function showRandomPlan() {
            if (!currentFilteredPlans || currentFilteredPlans.length === 0) {
                showMessage('Список планов пуст или фильтры не вернули результатов.', 'Нечего выбирать');
                return;
            }
            const randomIndex = Math.floor(Math.random() * currentFilteredPlans.length);
            const [filmId, planData] = currentFilteredPlans[randomIndex];
            showMovieDetails(filmId, false);
        }
        
        const slugify = text => text.toString().toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-');
        const normalizeTitle = (title) => title.toLowerCase().replace(/[^a-z0-9а-я]/g, '');

        async function getAnimeFillerInfo(animeTitle) {
            const slug = slugify(animeTitle);
            if (animeFillerCache[slug]) return animeFillerCache[slug];
            try {
                const response = await fetch(`${CORS_PROXY_URL}${ANIME_FILLER_API_URL}${slug}`);
                if (!response.ok) return null;
                const data = await response.json();
                
                const fillerTitles = new Set();
                if (data.episodes) {
                    data.episodes.forEach(ep => {
                        if (ep['filler-type'] && ep['filler-type'].toLowerCase().includes('filler') && ep['episode-title']) {
                            filler
                        }
                    });
                }
                animeFillerCache[slug] = fillerTitles;
                return fillerTitles;
            } catch (e) {
                console.error("Error fetching filler info:", e);
                return null;
            }
        }
        
        async function openSeasonsModal(filmId) {
            const modal = document.getElementById('seasons-modal');
            const titleEl = document.getElementById('seasons-title');
            const contentEl = document.getElementById('seasons-content');
            const filmData = await getFullMovieData(filmId);
        
            if (!filmData) return;
        
            // Очищаем память предыдущего поиска
            lastEpisodeAiQuery = '';
            lastEpisodeAiResponse = '';

            titleEl.textContent = filmData.name || filmData.title;
            contentEl.innerHTML = `<p class="loading-indicator">Загрузка сезонов...</p>`;
            openModal(modal);

            const isAnime = filmData.media_type === 'tv' && filmData.genres.some(g => g.id === ANIMATION_GENRE_ID);
            
            const tmdbTvDetails = await fetchProxiedApi(buildTmdbUrl(`/tv/${filmData.id}`));
            const seasonsData = tmdbTvDetails?.seasons?.filter(s => s.season_number > 0 && s.episode_count > 0);
        
            if (!seasonsData || seasonsData.length === 0) {
                contentEl.innerHTML = `<p>Информация о сезонах не найдена.</p>`;
                return;
            }
            
                                    contentEl.innerHTML = `
                <div id="seasons-header">
                    <select id="season-select-list"></select>
                    <div class="season-header-right">
                        <div id="season-rating"></div>
                        <button id="episode-search-toggle" title="Поиск серии с помощью ИИ">✨</button>
                    </div>
                </div>
                <div id="episode-search-container">
                    <div id="episode-search-controls">
                        <div class="search-input-container">
                            <input type="text" id="episode-ai-search-input" placeholder="Опишите событие в серии...">
                            <button type="button" class="input-clear-btn">×</button>
                        </div>
                        <button type="button" id="episode-ai-search-btn" title="Найти">🔎</button>
                    </div>
                </div>
                <div id="episodes-list-container" style="position: relative; flex-grow: 1; display: flex; flex-direction: column;">
                    <div id="episode-search-overlay">ИИ ищет серию...</div>
                    <div id="episodes-list"><p class="loading-indicator">Загрузка серий...</p></div>
                </div>`;
        
            const seasonSelect = document.getElementById('season-select-list');
            const seriesTitle = filmData.name || filmData.title; // Получаем название всего сериала

            seasonsData.forEach(season => {
                const option = document.createElement('option');
                option.value = season.season_number;

                const apiName = season.name || '';
                const defaultName = `Сезон ${season.season_number}`;

                // Если название от API пустое или начинается с названия сериала,
                // то мы используем наше стандартное, красивое название.
                if (!apiName || apiName.toLowerCase().startsWith(seriesTitle.toLowerCase())) {
                    option.textContent = defaultName;
                } else {
                    // Иначе (если название уникальное) мы его оставляем.
                    option.textContent = apiName;
                }
                
                seasonSelect.appendChild(option);
            });

            // "Оживляем" кнопку очистки для нового поля ввода
            const episodeSearchInput = document.getElementById('episode-ai-search-input');
            const episodeClearBtn = episodeSearchInput.nextElementSibling;
            
            const toggleClearBtn = () => {
                episodeClearBtn.style.display = episodeSearchInput.value ? 'block' : 'none';
            };
            
            episodeSearchInput.addEventListener('input', toggleClearBtn);
            episodeClearBtn.addEventListener('click', () => {
                episodeSearchInput.value = '';
                toggleClearBtn();
            });
            toggleClearBtn(); // Первоначальная проверка
            
            const fillerInfo = isAnime ? await getAnimeFillerInfo(filmData.name || filmData.title) : null;

            const searchToggle = document.getElementById('episode-search-toggle');
            const searchContainer = document.getElementById('episode-search-container');
            searchToggle.addEventListener('click', () => {
                const isExpanded = searchContainer.classList.toggle('expanded');
                searchToggle.classList.toggle('expanded', isExpanded);
                // Меняем иконку в зависимости от состояния
                if (isExpanded) {
                    searchToggle.innerHTML = '✕';
                    searchToggle.title = 'Закрыть поиск';
                } else {
                    searchToggle.innerHTML = '✨';
                    searchToggle.title = 'Поиск серии с помощью ИИ';
                }
            });

            // Убеждаемся, что обработчик для разворачивания названий добавляется только один раз
            if (!modal.dataset.listenerAdded) {
                modal.addEventListener('click', (e) => {
                    const clickedItem = e.target.closest('.episode-item');
                    if (!clickedItem) return;

                    const list = clickedItem.closest('#episodes-list');
                    if (!list) return;

                    list.querySelectorAll('.episode-item.expanded').forEach(item => {
                        if (item !== clickedItem) {
                            item.classList.remove('expanded');
                        }
                    });
                    
                    clickedItem.classList.toggle('expanded');
                });
                // Ставим "флажок", что обработчик уже добавлен
                modal.dataset.listenerAdded = 'true';
            }

            document.getElementById('episode-ai-search-btn').addEventListener('click', async () => {
                const seriesName = filmData.name || filmData.title;
                const query = document.getElementById('episode-ai-search-input').value;
                if (!query) return;
                await performEpisodeAiSearch(seriesName, query, filmId, fillerInfo);
            });

            seasonSelect.addEventListener('change', async () => await displaySeasonDetails(filmId, seasonSelect.value, fillerInfo));
            await displaySeasonDetails(filmId, seasonSelect.value, fillerInfo);
        }

                        async function displaySeasonDetails(filmId, seasonNumber, fillerInfo, callback = null) {
            const episodesListEl = document.getElementById('episodes-list');
            const seasonRatingEl = document.getElementById('season-rating');
            episodesListEl.innerHTML = `<p class="loading-indicator">Загрузка серий...</p>`;
            seasonRatingEl.innerHTML = '';

            const [type, id] = filmId.split('-');
            const seasonDetails = await fetchProxiedApi(buildTmdbUrl(`/tv/${id}/season/${seasonNumber}`));

            if (!seasonDetails || !seasonDetails.episodes) {
                episodesListEl.innerHTML = `<p>Не удалось загрузить серии.</p>`;
                return;
            }
            
            if (seasonDetails.vote_average > 0) {
                const score = seasonDetails.vote_average.toFixed(1);
                seasonRatingEl.innerHTML = `<span style="color: ${getScoreColor(score)}">★ ${score}</span>`;
            }

            const plan = plans[filmId];
            let progressEpisodeNumber = 0;
            if (plan && plan.season == seasonNumber) {
                 progressEpisodeNumber = plan.episode;
            }
            
            let episodesHTML = '';
            for (const episode of seasonDetails.episodes) {
                const airDate = episode.air_date ? new Date(episode.air_date).toLocaleDateString('ru-RU', { day: 'numeric', month: 'short', year: 'numeric' }) : 'нет данных';
                const score = episode.vote_average ? episode.vote_average.toFixed(1) : '-';
                const votes = episode.vote_count > 0 ? `(${episode.vote_count})` : '';
                const isFiller = fillerInfo && episode.name && fillerInfo.has(normalizeTitle(episode.name));
                const fillerBadge = isFiller ? '<span class="filler-badge">F</span>' : '';
                const watchedIndicatorClass = progressEpisodeNumber > 0 && episode.episode_number <= progressEpisodeNumber ? 'watched-indicator' : '';
                
                episodesHTML += `<div class="episode-item ${watchedIndicatorClass}" data-episode-number="${episode.episode_number}">
                    <div class="episode-number">${episode.episode_number}</div>
                    <div class="episode-details">
                        <div class="episode-title">${episode.name || `Эпизод ${episode.episode_number}`}${fillerBadge}</div>
                        <div class="episode-air-date">${airDate}</div>
                    </div>
                    <div class="episode-rating">
                        <div class="episode-rating-score" style="color: ${getScoreColor(episode.vote_average)}">★ ${score}</div>
                        <div class="episode-rating-votes">${votes}</div>
                    </div>
                </div>`;
            }
            episodesListEl.innerHTML = episodesHTML;
            
            if (callback) {
                setTimeout(callback, 100);
            }
            
        }
        

        // --- FILMOGRAPHY FUNCTIONS ---
        function enterFilmographyMode() {
            document.body.classList.add('filmography-mode');
            document.getElementById('filmography-filters').style.display = 'grid';
            const searchControls = document.querySelector('.search-controls-wrapper');
            const randomBtn = document.getElementById('random-movie-btn');
            searchControls.appendChild(randomBtn);
        }

        function exitFilmographyMode() {
            document.body.classList.remove('filmography-mode');
            document.getElementById('filmography-filters').style.display = 'none';
            const topRow = document.querySelector('.search-top-row');
            const randomBtn = document.getElementById('random-movie-btn');
            topRow.appendChild(randomBtn);
            currentFilmography = [];
        }

        function resetSearchView() {
            exitFilmographyMode();
            document.getElementById('subtitle-text').textContent = initialSubtitle;
            document.getElementById('search-input').value = '';
            loadInitialContent();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        async function showActorFilmography(personId, personName) {
            closeModal(document.getElementById('movie-details-modal'));
            
            document.querySelector('.tab-button[data-tab="search-view"]').click();
            document.getElementById('subtitle-text').textContent = `Фильмография: ${personName}`;
            movieGrid.innerHTML = `<p class="loading-indicator">Загрузка работ...</p>`;
            enterFilmographyMode();
            window.scrollTo({ top: 0, behavior: 'smooth' });

            try {
                const url = buildTmdbUrl(`/person/${personId}/combined_credits`);
                const data = await fetchProxiedApi(url);
                if (data && data.cast) {
                    const excludedGenreIds = [10767, 10764, 10763]; // Talk, Reality, News
                    currentFilmography = data.cast.filter(item => {
                        if (!item.genre_ids || !item.poster_path) return false;
                        return !item.genre_ids.some(id => excludedGenreIds.includes(id));
                    });
                    
                    const typeSelect = document.getElementById('filmography-type');
                    typeSelect.innerHTML = '<option value="all">Все</option><option value="movie">Фильмы</option><option value="tv">Сериалы</option>';
                    
                    const hasAnimatedMovies = currentFilmography.some(item => item.media_type === 'movie' && item.genre_ids.includes(ANIMATION_GENRE_ID));
                    const hasAnimatedSeries = currentFilmography.some(item => item.media_type === 'tv' && item.genre_ids.includes(ANIMATION_GENRE_ID));

                    if(hasAnimatedMovies) typeSelect.insertAdjacentHTML('beforeend', '<option value="animated_movie">Мультфильмы</option>');
                    if(hasAnimatedSeries) typeSelect.insertAdjacentHTML('beforeend', '<option value="animated_tv">Мультсериалы</option>');

                    displayFilteredFilmography();
                } else {
                    movieGrid.innerHTML = `<p class="no-results-message">Не удалось загрузить фильмографию.</p>`;
                }
            } catch (e) {
                console.error("Error fetching filmography:", e);
                movieGrid.innerHTML = `<p class="no-results-message">Ошибка при загрузке.</p>`;
            }
        }

        function displayFilteredFilmography() {
            const sort = document.getElementById('filmography-sort').value;
            const type = document.getElementById('filmography-type').value;
            const genre = document.getElementById('filmography-genre').value;
            const decadeOption = document.getElementById('filmography-decade').selectedOptions[0];
            const startYear = decadeOption.dataset.startYear;
            const endYear = decadeOption.dataset.endYear;
            const query = document.getElementById('search-input').value.trim().toLowerCase();

            let filtered = [...currentFilmography];

            if (type === 'animated_movie') {
                filtered = filtered.filter(item => item.media_type === 'movie' && item.genre_ids.includes(ANIMATION_GENRE_ID));
            } else if (type === 'animated_tv') {
                filtered = filtered.filter(item => item.media_type === 'tv' && item.genre_ids.includes(ANIMATION_GENRE_ID));
            } else if (type !== 'all') {
                filtered = filtered.filter(item => item.media_type === type);
            }

            if (genre !== 'any') {
                filtered = filtered.filter(item => item.genre_ids.includes(parseInt(genre, 10)));
            }
            
            if (startYear) {
                filtered = filtered.filter(item => {
                    const year = parseInt((item.release_date || item.first_air_date || '0').substring(0, 4), 10);
                    return year >= parseInt(startYear, 10) && year <= parseInt(startYear, 10) + 9;
                });
            } else if (endYear) {
                filtered = filtered.filter(item => {
                    const year = parseInt((item.release_date || item.first_air_date || '0').substring(0, 4), 10);
                    return year <= parseInt(endYear, 10);
                });
            }

            if (query) {
                filtered = filtered.filter(item => (item.title || item.name || '').toLowerCase().includes(query) || (item.original_title || item.original_name || '').toLowerCase().includes(query));
            }

            switch (sort) {
                case 'popularity':
                    filtered.sort((a, b) => (b.vote_count || 0) - (a.vote_count || 0));
                    break;
                case 'newest':
                    filtered.sort((a, b) => new Date(b.release_date || b.first_air_date || 0) - new Date(a.release_date || a.first_air_date || 0));
                    break;
                case 'oldest':
                    filtered.sort((a, b) => new Date(a.release_date || a.first_air_date || 0) - new Date(b.release_date || b.first_air_date || 0));
                    break;
            }

            displayMovies({ results: filtered }, true);
        }

        function showRandomFilmographyItem() {
            const itemsOnGrid = movieGrid.querySelectorAll('.movie-card');
            if (itemsOnGrid.length === 0) {
                showMessage("Нет элементов для выбора. Попробуйте изменить фильтры.", "Упс!");
                return;
            }
            const randomItem = itemsOnGrid[Math.floor(Math.random() * itemsOnGrid.length)];
            const filmId = randomItem.dataset.id;
            if (filmId) {
                showMovieDetails(filmId);
            }
        }
        
        // --- AI EPISODE SEARCH ---
                        async function performEpisodeAiSearch(seriesName, userQuery, filmId, fillerInfo) {
            if (Date.now() < episodeAiSearchCooldownEnd) return;
        
            const button = document.getElementById('episode-ai-search-btn');
            const searchInput = document.getElementById('episode-ai-search-input');
            const seasonSelect = document.getElementById('season-select-list');
            const overlay = document.getElementById('episode-search-overlay');
            
            searchInput.disabled = true;
            button.disabled = true;
            overlay.style.display = 'flex';
        
            try {
                let prompt = `Скажи точный сезон и серию и ничего более: в сериале "${seriesName}" в каком сезоне и какой серии происходит: ${userQuery}`;

                // Если это повторный запрос, просим ИИ не повторяться
                if (userQuery === lastEpisodeAiQuery && lastEpisodeAiResponse) {
                    prompt += `\n\nВАЖНО: Предыдущий ответ был "${lastEpisodeAiResponse}". Дай другой результат, не повторяйся.`;
                }

                const response = await fetch(DEEPSEEK_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${DEEPSEEK_API_KEY}` },
                    body: JSON.stringify({ model: "deepseek-chat", messages: [{ role: "user", content: prompt }] })
                });
                if (!response.ok) throw new Error("AI API request failed");
        
                const data = await response.json();
                const aiResponseText = data.choices?.[0]?.message?.content || "";
                
                // Обновляем память ПОСЛЕ получения ответа
                lastEpisodeAiQuery = userQuery;
                lastEpisodeAiResponse = aiResponseText.trim();
                
                const seasonMatch = aiResponseText.match(/сезон\s*(\d+)/i);
                const episodeMatch = aiResponseText.match(/сери(?:я|и)\s*(\d+)/i);
                
                if (seasonMatch && episodeMatch) {
                    const seasonNum = parseInt(seasonMatch[1], 10);
                    const episodeNum = parseInt(episodeMatch[1], 10);
                    const highlightAction = () => highlightEpisode(episodeNum, aiResponseText);

                    if (seasonSelect.value != seasonNum) {
                        if (seasonSelect.querySelector(`option[value="${seasonNum}"]`)) {
                            seasonSelect.value = seasonNum;
                            await displaySeasonDetails(filmId, seasonNum, fillerInfo, highlightAction);
                        } else {
                            showMessage(`Мы не нашли такой сезон у себя в базе, но, возможно, вы ищете:\n\n${aiResponseText}`, 'Результат от ИИ');
                            return;
                        }
                    } else {
                        highlightAction();
                    }
                } else {
                    showMessage(`ИИ не смог определить точный номер сезона и серии. Вот его ответ:\n\n${aiResponseText}`, 'Результат от ИИ');
                }
            } catch (e) {
                console.error("Episode AI search error:", e);
                showMessage("Произошла ошибка при поиске серии с помощью ИИ.", "Ошибка");
            } finally {
                overlay.style.display = 'none';
                searchInput.disabled = false;
                episodeAiSearchCooldownEnd = Date.now() + 15000;
                manageCooldown(button, 15000, '✨');
            }
        }
        
        function highlightEpisode(episodeNum, aiResponseText) {
            const episodeItem = document.querySelector(`.episode-item[data-episode-number="${episodeNum}"]`);
            if (episodeItem) {
                episodeItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                episodeItem.classList.add('highlighted');
                setTimeout(() => episodeItem.classList.remove('highlighted'), 1500);
            } else {
                showAiToast(`ИИ ответил: ${aiResponseText} (серия не найдена в сезоне)`);
            }
        }

        function showAiToast(message) {
            const modalContent = document.querySelector('#seasons-modal .modal-content');
            if (!modalContent) return;

            let toast = modalContent.querySelector('.ai-toast-notification');
            if (toast) toast.remove();

            toast = document.createElement('div');
            toast.className = 'ai-toast-notification';
            toast.textContent = message;
            modalContent.appendChild(toast);
            
            setTimeout(() => toast.classList.add('visible'), 50);
            setTimeout(() => {
                toast.classList.remove('visible');
                setTimeout(() => toast.remove(), 300);
            }, 5000);
        }

        // --- ADMIN PANEL ---
        function logAdminAction(actionText) { try { let actions = JSON.parse(localStorage.getItem('adminActionsLog') || '[]'); actions.unshift({ text: actionText, time: new Date().toISOString() }); actions = actions.slice(0, 20); localStorage.setItem('adminActionsLog', JSON.stringify(actions)); } catch(e) { console.error("Error logging admin action:", e); } }
        async function openAdminPanel() { const adminPasswordPrompt = document.getElementById('admin-password-prompt'); openModal(adminPasswordPrompt); }
        
        async function displayAdminPanelContent() { 
            await loadInitialData(); 
            displayUserStats(); 
            displayKeyManagement(); 
            displayLastActions(); 
            setupAdminSettings(); 
        }

        function setupAdminSettings() {
            renderAdminCountryFilters();
            
            document.querySelectorAll('#admin-settings-content input[data-country]').forEach(checkbox => {
                checkbox.checked = hiddenCountries.includes(checkbox.dataset.country);
            });
            const disableAnimeSwitch = document.getElementById('disable-anime-switch');
            if(disableAnimeSwitch) disableAnimeSwitch.checked = disableAnime;
        }

        function renderAdminCountryFilters() {
            const mainContainer = document.getElementById('country-filters');
            const collapsibleContainer = document.querySelector('.country-filter-collapsible');
            mainContainer.innerHTML = '';
            collapsibleContainer.innerHTML = '';
            
            const countries = [
                { name: 'Великобритания', code: 'GB', emoji: '🇬🇧' },
                { name: 'Германия', code: 'DE', emoji: '🇩🇪' },
                { name: 'Индия', code: 'IN', emoji: '🇮🇳' },
                { name: 'Испания', code: 'ES', emoji: '🇪🇸' },
                { name: 'Канада', code: 'CA', emoji: '🇨🇦' },
                { name: 'Китай', code: 'CN', emoji: '🇨🇳' },
                { name: 'Корея', code: 'KR', emoji: '🇰🇷' },
                { name: 'Россия', code: 'RU', emoji: '🇷🇺' },
                { name: 'США', code: 'US', emoji: '🇺🇸' },
                { name: 'Франция', code: 'FR', emoji: '🇫🇷' },
                { name: 'Япония', code: 'JP', emoji: '🇯🇵' },
            ];

            countries.sort((a, b) => a.name.localeCompare(b.name, 'ru'));
            const mainCountriesCodes = ['KR', 'CN', 'IN', 'JP', 'GB', 'RU'];

            countries.forEach(country => {
                const html = `<div class="switch-container"><span>${country.emoji} ${country.name}</span><label class="switch"><input type="checkbox" data-country="${country.code}"><span class="slider round"></span></label></div>`;
                if (mainCountriesCodes.includes(country.code)) {
                    mainContainer.insertAdjacentHTML('beforeend', html);
                } else {
                    collapsibleContainer.insertAdjacentHTML('beforeend', html);
                }
            });
        }


        async function updateCountryFilters() {
            hiddenCountries = Array.from(document.querySelectorAll('#admin-settings-content input[data-country]:checked')).map(cb => cb.dataset.country);
            try {
                await postToApi('save_setting', { key: 'hidden_countries', value: hiddenCountries });
                logAdminAction(`🌍 Фильтры стран обновлены: ${hiddenCountries.join(', ') || 'нет'}`);
            } catch(e) { console.error("Failed to update country filters:", e); }
        }

        function displayUserStats(){
            document.getElementById('total-rated-stat').textContent = Object.keys(ratings).length;
            document.getElementById('total-planned-stat').textContent = Object.keys(plans).length;
            const container = document.getElementById('user-stats-container');
            container.innerHTML = '';
            ['katya', 'maxim'].forEach(person => {
                const userRatings = Object.values(ratings).map(r => r[person]).filter(r => r && r.score > 0);
                let totalScore = 0;
                const scoreCounts = { low: 0, mid: 0, high: 0 };
                userRatings.forEach(r => {
                    totalScore += r.score;
                    if (r.score <= 4.5) scoreCounts.low++;
                    else if (r.score <= 7.5) scoreCounts.mid++;
                    else scoreCounts.high++;
                });
                const avgScore = userRatings.length > 0 ? (totalScore / userRatings.length).toFixed(2) : 'N/A';
                const totalNumeric = scoreCounts.low + scoreCounts.mid + scoreCounts.high;

                let statsHtml = `<div class="user-stats-card">
                                <h3>${person === 'katya' ? '😺 Катя' : '👾 Максим'}</h3>
                                <div class="stat-item"><span>Всего оценок</span><span>${userRatings.length}</span></div>
                                <div class="stat-item"><span>Средний балл</span><span>${avgScore}</span></div>
                                <div class="stats-bar-chart">
                                    <div class="bar-row">
                                        <div class="bar-label">Высокие</div>
                                        <div class="bar-container"><div class="bar-fill" style="width: ${totalNumeric > 0 ? (scoreCounts.high / totalNumeric) * 100 : 0}%; background-color: #22c55e;">${scoreCounts.high}</div></div>
                                    </div>
                                    <div class="bar-row">
                                        <div class="bar-label">Средние</div>
                                        <div class="bar-container"><div class="bar-fill" style="width: ${totalNumeric > 0 ? (scoreCounts.mid / totalNumeric) * 100 : 0}%; background-color: #facc15;">${scoreCounts.mid}</div></div>
                                    </div>
                                    <div class="bar-row">
                                        <div class="bar-label">Низкие</div>
                                        <div class="bar-container"><div class="bar-fill" style="width: ${totalNumeric > 0 ? (scoreCounts.low / totalNumeric) * 100 : 0}%; background-color: var(--danger-color);">${scoreCounts.low}</div></div>
                                    </div>
                                </div>
                             </div>`;
                container.innerHTML += statsHtml;
            });
        }
        function displayKeyManagement(){
            const tbody = document.getElementById('kp-keys-tbody');
            const header = document.getElementById('kp-keys-header');
            tbody.innerHTML = '';
            const now = Date.now();
            
            const sortedKeys = [...kpApiKeysManager.keys].sort((a, b) => {
                const aDisabled = a.disabledUntil && a.disabledUntil > now;
                const bDisabled = b.disabledUntil && b.disabledUntil > now;
                if (aDisabled !== bDisabled) return aDisabled - bDisabled;
                return (a.key || '').localeCompare(b.key || '');
            });
            
            const activeKeysCount = sortedKeys.filter(k => !k.disabledUntil || k.disabledUntil < now).length;
            header.querySelector('.key-counter').innerHTML = `(<span class="key-status-ok">${activeKeysCount}</span> / <span class="key-status-disabled">${sortedKeys.length - activeKeysCount}</span>)`;
            
            sortedKeys.forEach(k => {
                let status;
                 if (k.disabledUntil && k.disabledUntil > now) {
                    const remainingMs = k.disabledUntil - now;
                    const hours = Math.floor(remainingMs / 3600000);
                    const minutes = Math.floor((remainingMs % 3600000) / 60000);
                    status = `<span class="key-status-disabled">Отключен (~${hours}ч ${minutes}м)</span>`;
                } else {
                    status = `<span class="key-status-ok">OK</span>`;
                }
                tbody.innerHTML += `<tr><td>${k.key.substring(0,8)}...</td><td>${k.count}</td><td>${status}</td><td><button class="key-delete-btn" data-key-id="${k.id}" data-type="kp">×</button></td></tr>`;
            });
        }
        function displayLastActions() { const list = document.getElementById('last-actions-list'); list.innerHTML = ''; const actions = JSON.parse(localStorage.getItem('adminActionsLog') || '[]'); if (actions.length === 0) { list.innerHTML = '<li>Действий пока нет.</li>'; return; } actions.forEach(action => { list.innerHTML += `<li>${action.text}</li>`; }); }
        
        function setupAdminPanelListeners() {
            document.querySelector('.admin-nav').addEventListener('click', async (e) => {
                const btn = e.target.closest('.admin-nav-btn');
                if (!btn || btn.classList.contains('active')) return;

                if (btn.dataset.tab === 'admin-management' && localStorage.getItem('isAdminVerified') !== 'true') {
                    e.preventDefault();
                    await openAdminPanel();
                    return;
                }

                document.querySelector('.admin-nav-btn.active').classList.remove('active');
                document.querySelector('.admin-content.active').classList.remove('active');
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab).classList.add('active');
            });
            
            const adminPasswordPrompt = document.getElementById('admin-password-prompt');
            adminPasswordPrompt.addEventListener('click', e => {
                if (e.target === adminPasswordPrompt) {
                    closeModal(adminPasswordPrompt);
                }
            });

            document.getElementById('admin-password-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const input = document.getElementById('admin-password-input');
                if(input.value.toLowerCase() === 'panasonic') {
                    localStorage.setItem('isAdminVerified', 'true');
                    closeModal(adminPasswordPrompt);
                    document.querySelector('.admin-nav-btn[data-tab="admin-management"]').click();
                } else {
                    input.value='';
                    input.style.border='1px solid var(--danger-color)';
                    setTimeout(()=>input.style.border='1px solid #475569',1000);
                }
            });
            
            const kpKeysHeader = document.getElementById('kp-keys-header');
            const kpKeysContent = document.getElementById('kp-keys-content');
            if (kpKeysHeader && kpKeysContent) {
                if (!kpKeysHeader.querySelector('.key-counter')) {
                     kpKeysHeader.innerHTML += ' <span class="key-counter"></span>';
                }
                kpKeysHeader.addEventListener('click', () => {
                    kpKeysContent.classList.toggle('collapsed');
                    kpKeysHeader.classList.toggle('collapsed');
                });
            }

            document.getElementById('add-key-form').addEventListener('submit', async (e) => { e.preventDefault(); const input = document.getElementById('new-kp-key-input'); if (await kpApiKeysManager.addKey(input.value.trim())) { input.value = ''; input.dispatchEvent(new Event('input')); displayKeyManagement(); } else { showMessage('Неверный или дублирующийся ключ.', 'Ошибка'); } });
            
            document.getElementById('admin-management').addEventListener('click', async e => {
                const btn = e.target.closest('.key-delete-btn');
                if (btn) {
                    if (await showConfirmation(`Удалить этот ключ?`)) {
                        await kpApiKeysManager.deleteKey(btn.dataset.keyId);
                        displayKeyManagement();
                    }
                }
            });

            const countryToggle = document.querySelector('.country-filter-toggle');
            if (countryToggle) {
                countryToggle.addEventListener('click', () => {
                    const collapsible = document.querySelector('.country-filter-collapsible');
                    const wrapper = document.querySelector('.country-filter-collapsible-wrapper');
                    const isExpanded = !collapsible.classList.contains('expanded');
                    
                    collapsible.classList.toggle('expanded');
                    countryToggle.classList.toggle('expanded');
                    
                    if (isExpanded) {
                        wrapper.appendChild(countryToggle);
                    } else {
                        wrapper.insertBefore(countryToggle, collapsible);
                    }
                });
            }

            document.getElementById('admin-settings-content').addEventListener('change', e => {
                if (e.target.closest('#country-filters') || e.target.closest('.country-filter-collapsible')) {
                    updateCountryFilters();
                }
            });

            const disableAnimeSwitch = document.getElementById('disable-anime-switch');
            if (disableAnimeSwitch) {
                disableAnimeSwitch.addEventListener('change', async (e) => {
                    const isChecked = e.target.checked;
                    disableAnime = isChecked;
                    try {
                        await postToApi('save_setting', { key: 'disable_anime', value: isChecked });
                        logAdminAction(`🎌 Аниме ${isChecked ? 'отключено' : 'включено'}.`);
                    } catch(err) {
                        console.error("Failed to update anime setting:", err);
                    }
                });
            }

            document.getElementById('download-ratings-btn').addEventListener('click', () => downloadCollection('ratings'));
            document.getElementById('download-plans-btn').addEventListener('click', () => downloadCollection('plans'));
            
            document.querySelectorAll('.import-form').forEach(form => {
                form.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const table = e.target.dataset.table;
                    const fileInput = e.target.querySelector('input[type="file"]');
                    const file = fileInput.files[0];
                    const button = e.target.querySelector('button');

                    if (!file) { showMessage('Пожалуйста, выберите файл.', 'Ошибка'); return; }
                    if (!await showConfirmation(`Вы уверены, что хотите импортировать данные в '${table}'? Все существующие данные в этой таблице будут УДАЛЕНЫ.`)) return;

                    toggleButtonLoading(button, true, '', 'Импорт...');
                    
                    const formData = new FormData();
                    formData.append('jsonFile', file);
                    formData.append('table', table);

                    try {
                        const result = await postToApi(`import_${table === 'kp_api_keys' ? 'kp_keys' : 'data'}`, formData, true);
                        
                        showMessage(`Успешно! ${result.message}`, "Импорт завершен");
                        logAdminAction(`📦 Выполнен импорт в таблицу ${table}.`);
                        await loadInitialData();
                        displayAdminPanelContent();
                        if (document.getElementById(`${table}-view`)?.classList.contains('active')) {
                            table === 'ratings' ? displayRatedMovies(true) : displayPlans(true);
                        }
                    } catch (error) {
                        showMessage(`Ошибка импорта: ${error.message}`, "Ошибка");
                        console.error(error);
                    } finally {
                        toggleButtonLoading(button, false, `Импорт ${table}`);
                        fileInput.value = '';
                    }
                });
            });

            document.getElementById('clear-cache-btn').addEventListener('click', async () => { if(await showConfirmation("Вы уверены, что хотите очистить ВЕСЬ кэш сайта (включая авторизацию)? Страница будет перезагружена.")){ localStorage.clear(); sessionStorage.clear(); location.reload(); }});
        }
        function downloadFile(filename, text) { const element = document.createElement('a'); element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(text)); element.setAttribute('download', filename); element.style.display = 'none'; document.body.appendChild(element); element.click(); document.body.removeChild(element); }
        function downloadCollection(name) { const data = name === 'ratings' ? ratings : plans; downloadFile(`${name}.json`, JSON.stringify(data, null, 2)); }
        
        // --- END ADMIN PANEL ---

        init();
    });
    </script>
</body>
</html>